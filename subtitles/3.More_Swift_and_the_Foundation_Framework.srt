1
00:00:00,401 --> 00:00:04,536
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:04,605 --> 00:00:10,876
Stanford University. Welcome to Stanford CS193P,
斯坦福大学。>> 欢迎参加 2017 年冬季学期

3
00:00:10,945 --> 00:00:14,279
this is Developing Applications for iOS,
斯坦福 CS193P 课程，iOS 应用程序开发

4
00:00:14,347 --> 00:00:18,984
winter of 2017. This is the only lecture in this quarter
这是本季度唯一一节我不打算

5
00:00:19,052 --> 00:00:23,122
where I'm not going to do a demo, so this is all slides,
做示例程序的课，这次全是幻灯片

6
00:00:23,190 --> 00:00:27,025
and that's because I'm pretty much going to try and
那是因为我很想

7
00:00:27,094 --> 00:00:31,329
get you fully up to speed on Swift. Everything that I'm
让你们完全掌握 Swift。我今天讲到的内容

8
00:00:31,398 --> 00:00:34,233
going to talk about today is covered either in your reading
包括在你们的今天截止的阅读任务一

9
00:00:34,301 --> 00:00:37,236
assignment one, which was due today, so hopefully you're
所以希望你们已经完成了这项作业

10
00:00:37,304 --> 00:00:39,904
done with that, or it's in reading assignment two,
或者是在阅读任务二中

11
00:00:39,973 --> 00:00:43,942
which is going out today and is due next Wednesday. So,
也就是今天的作业，下周三截止

12
00:00:44,010 --> 00:00:47,011
why am I even covering this? Because I know that reading
所以为什么我竟然会包括这个呢？因为我知道

13
00:00:47,080 --> 00:00:50,115
through that reading assignment can be a big slog
那个阅读任务的信息量太大，全部读完

14
00:00:50,184 --> 00:00:53,384
through a lot of information, and I want you to understand
并不是一件令人愉悦的事情

15
00:00:53,453 --> 00:00:56,822
the things in there that are really important. As I go
并且我希望你们能理解这些非常重要

16
00:00:56,890 --> 00:00:59,358
through the slides today, if you see something and
今天我播放幻灯片的时候，如果你看到一些东西

17
00:00:59,426 --> 00:01:03,094
I explain it and you're like, my gosh I didn't get that,
或我对它的解释让你感觉 “我天完全搞不懂”

18
00:01:03,163 --> 00:01:06,131
just make a note about whatever the topic is that I'm
先把我讲的内容记下来

19
00:01:06,200 --> 00:01:07,532
talking about and then you can go back and
等回去之后你可以再次

20
00:01:07,601 --> 00:01:09,667
read about it again in your reading assignment to try and
试着通过阅读任务的相关内容理解

21
00:01:09,736 --> 00:01:11,770
understand it. If you still don't understand it,
如果你依然搞不懂

22
00:01:11,839 --> 00:01:15,440
you can of course ask on the class forums.
你当然可以在课堂论坛上提问

23
00:01:15,509 --> 00:01:18,443
You can think of this as kind of the highlights of the first
你可以把这当成给最开始的

24
00:01:18,512 --> 00:01:21,613
two reading assignments. Some of these are also highlights
两个阅读任务勾重点

25
00:01:21,682 --> 00:01:24,283
of the first two lectures I did in the demos,
最开始两节课的示例程序中的重点

26
00:01:24,351 --> 00:01:25,817
so there's a little bit of that in there too.
也会包含一些

27
00:01:25,886 --> 00:01:28,787
But, this is really kind of the important stuff in Swift,
但是，我现在教你们的

28
00:01:28,855 --> 00:01:30,121
that I can teach you at this point.
真的是 Swift 中很重要的内容

29
00:01:30,190 --> 00:01:33,758
There's more important stuff in Swift to come, okay,
Swift 中还有更重要的东西要讲

30
00:01:33,827 --> 00:01:38,263
but I'll teaching it kinda as we go in the next two weeks.
但我大概将会在接下来的两周里讲解

31
00:01:38,332 --> 00:01:41,500
Okay, so lot of Swift topics,
好了，这么多 Swift 的话题

32
00:01:41,569 --> 00:01:43,769
let's start with the first one, probably everybody's
让我们从第一个开始，大概所有人

33
00:01:43,837 --> 00:01:45,537
favorite topic when they first learn Swift,
刚开始学习 Swift 时最喜欢的话题

34
00:01:45,606 --> 00:01:50,275
which is optional. Optional is interesting in Swift,
就是 Optional。Swift 中的 Optional 很有意思

35
00:01:50,344 --> 00:01:53,345
because not a lot of other languages have optional, so
因为其他有 Optional 的语言并不多，所以

36
00:01:53,413 --> 00:01:56,047
I'm sure, in fact I've heard, that some of you are like,
我很确定，实际上我已经听说了，就是你们中有些人感觉

37
00:01:56,116 --> 00:01:58,250
"Hmm, I'm not sure I really understand that optional
“额，我不确定我真的理解了 Optional 是个啥东西”

38
00:01:58,318 --> 00:02:02,654
thing". And that's probably okay, but by the end of next
这没关系，但是在下周结束之前

39
00:02:02,723 --> 00:02:04,956
week you should feel very confident with Optionals,
你应该会感到对 Optional 很有把握了

40
00:02:05,025 --> 00:02:07,659
because you're gonna see that they are absolutely everywhere
因为你将会看到它们实际上会出现在 iOS 中的任何地方

41
00:02:07,728 --> 00:02:10,696
in iOS. Now, I mentioned this in the lecture but
我在课上提到这个

42
00:02:10,765 --> 00:02:12,497
I wanted to show it to you from a code,
但是我想用一段代码向你展示它

43
00:02:12,566 --> 00:02:16,134
kind of a code point of view, which is that optional
从代码的角度来看

44
00:02:16,203 --> 00:02:19,971
is nothing more than an enum, it is fact just an enum,
Optional 实际上就是个枚举

45
00:02:20,040 --> 00:02:23,408
this is the enum that is an optional. It's a generic type,
这是 Optional 作为泛型枚举的定义

46
00:02:23,476 --> 00:02:26,011
kind of like array, how with array when you say the type,
有点像 Array<T>，泛型数组的定义

47
00:02:26,080 --> 00:02:29,013
you say the type of the thing you're putting in the array.
需要声明元素的类型

48
00:02:29,082 --> 00:02:31,783
You should all be familiar to that, with that from Java for
你们对此应该都不陌生，就像 Java 一样

49
00:02:31,852 --> 00:02:33,351
example, same thing in Swift.
在 Swift 中也是一样的

50
00:02:33,420 --> 00:02:35,053
So, with optional it is the same way,
同理，对于 Optional

51
00:02:35,122 --> 00:02:38,189
you put this type, the type that's associated, there,
尖括号里的类型 T

52
00:02:38,258 --> 00:02:39,524
or not that's associated, but
不是作为实际关联值的类型

53
00:02:39,593 --> 00:02:41,393
the type of the generic type that we're talking about.
而是我们正在谈论的泛型

54
00:02:41,462 --> 00:02:42,727
that "T" in an optional,
Optional 中的那个 T

55
00:02:42,796 --> 00:02:45,297
is just the type that's going to be the associated value.
相当于关联值的占位符

56
00:02:45,366 --> 00:02:48,533
When you look at this enum Optional,
这个枚举 Optional

57
00:02:48,602 --> 00:02:53,005
it only has two cases: "none" which is "not set," and
它只有两种情况：.none，未赋值

58
00:02:53,073 --> 00:02:56,241
"some" which is "set". When it's in the some case, look:
和 .some，已赋值。当它为 .some 时

59
00:02:56,310 --> 00:02:59,645
"(T)". You know what that is from the calculator demo,
注意这个 (T)。从计算器示例程序中你们知道

60
00:02:59,713 --> 00:03:02,480
that's an associated value, just like when we had
那是个关联值

61
00:03:02,549 --> 00:03:06,017
operation in calculator it had associated values, like unary
就像计算器中的运算

62
00:03:06,086 --> 00:03:09,087
operation had an associative value of a function, and
比如一元运算符有一个函数作为关联值

63
00:03:09,155 --> 00:03:12,824
constant had an associated value of the constant's value.
常量有一个关联的常量值

64
00:03:12,893 --> 00:03:15,260
Same thing here, with optional, in the "some" case,
Optional 的 .some 是一样的

65
00:03:15,329 --> 00:03:17,562
the "set" case, it just has an associated value, and
已赋值的情况下，它也有一个关联值

66
00:03:17,631 --> 00:03:19,498
it's whatever type the optional was, so
关联值的类型决定于可选值的类型

67
00:03:19,566 --> 00:03:22,500
if this is an optional string, then it would be a string.
如果这是个可选字符串，那么关联值将会是一个字符串

68
00:03:22,569 --> 00:03:28,240
Now what makes optional like, " I don't really get optional,
其实让你感到“我理解不了 Optional

69
00:03:28,309 --> 00:03:30,041
what is it?", it's because of all those question marks and
Optional 到底是个啥？”的原因

70
00:03:30,110 --> 00:03:32,577
exclamation points. But, all those question marks and
完全在于问号和感叹号

71
00:03:32,646 --> 00:03:35,146
exclamation points, are just sugar,
但是，所有这些问号和感叹号都只是语法糖

72
00:03:35,215 --> 00:03:39,218
syntactic sugar, to make your code look a little simpler and
目的是让代码看起来更简单和直观

73
00:03:39,286 --> 00:03:42,153
straight forward, because it's so common to use them. So,
特别是当它们经常被使用

74
00:03:42,222 --> 00:03:45,457
I'm going to map this enum to that sugar.
我把语法糖改用原本枚举的方法写出来

75
00:03:46,926 --> 00:03:51,897
Let's take a look, here's the first one: If I say let x:
让我们来看看，这是第一个：如果我写

76
00:03:51,966 --> 00:03:56,835
String?=nil, that's exactly the same as
let x: String? = nil，那和写

77
00:03:56,904 --> 00:04:01,840
saying let x = Optional<String>.none,
let x = Optional<String>.none 是完全一样的

78
00:04:01,908 --> 00:04:05,777
just like by saying array, I'd say
就像数组一样

79
00:04:05,845 --> 00:04:09,147
Array<String> that would mean I want an array of String,
Array<String> 意思是我想要一个字符串数组

80
00:04:09,216 --> 00:04:11,683
here when I say Optional <String>, that means I want
在这里当我说 Optional<String> 时，意思是我想要

81
00:04:11,752 --> 00:04:16,321
an Optional String. And I'm picking the none case, and
一个可选字符串，并且我选择了 .none

82
00:04:16,389 --> 00:04:20,125
in just the same way, if I say let x = Optional<string>=
用同样的方式，如果我写 let x: String? = "hello"

83
00:04:20,194 --> 00:04:24,329
hello, I'm just saying x = Optional<string>.some
相当于我写 let x = Optional<String>.some("hello")

84
00:04:24,398 --> 00:04:28,800
with associated value hello. Everyone got that? That's all
所有人都懂了吧？

85
00:04:28,869 --> 00:04:31,537
that's happening there with the question mark thing.
这就是关于问号的全部了

86
00:04:31,605 --> 00:04:34,839
And then here is the unwrap. When we do that exclamation
然后这里是解包。当我们写感叹号时

87
00:04:34,908 --> 00:04:38,410
point all we're doing is doing the switch to get things out
我们只是在写一个 switch 来把 Optional 里的

88
00:04:38,478 --> 00:04:42,914
of an optional, so we're switching on the optional,
内容拿出来，所以我们判断 Optional

89
00:04:42,983 --> 00:04:46,251
and it's in the "Some" case, then we're going to grab that
它处于 .some 情况下，那我们就抓取那个

90
00:04:46,319 --> 00:04:49,053
associated value just like we did in the calculator, and
关联值，就像我们在计算器中做的那样

91
00:04:49,122 --> 00:04:51,923
we say "let function" or "let value" to grab the associated
我们用 let function 或者 let value 去抓取关联值

92
00:04:51,992 --> 00:04:53,325
value, we're saying "let value" here and
在这里我们用 let value

93
00:04:53,393 --> 00:04:58,663
it's grabbing that value that's associated with it.
它抓取与它相关联的那个值

94
00:04:58,732 --> 00:05:00,798
If it's in case none, where it's not set,
如果它处于 .none 情况下，也就是未赋值时

95
00:05:00,867 --> 00:05:04,002
then it raises an exception and crashes your program,
它会抛出一个异常使你的程序崩溃

96
00:05:04,071 --> 00:05:07,572
we haven't talked about how to do that, it's quite easy, but
我们还没有谈到如何做，这很简单

97
00:05:07,641 --> 00:05:08,173
that's what happens here,
但这就是这里发生的事情

98
00:05:08,241 --> 00:05:10,843
that's all exclamation point is, it's basically a switch.
感叹号的本质就是一个 switch

99
00:05:11,979 --> 00:05:15,447
And then finally, If we do the "if let",
最后，如果我们执行 if let

100
00:05:15,515 --> 00:05:19,084
"if let" is also just a switch, but
if let 也只是个 switch

101
00:05:19,153 --> 00:05:22,254
in the none case of an if let, we don't raise an exception,
但是在 .none 时不会抛出异常

102
00:05:22,323 --> 00:05:26,658
we just break, break out of the switch, do nothing. Okay,
只会跳出这个 switch，什么都不做

103
00:05:26,726 --> 00:05:29,361
does that help you a little bit understand what optional
希望这对帮助你理解什么是 Optional 有点帮助

104
00:05:29,429 --> 00:05:32,931
is? Optional is a type, it's an enum, it's just like any
Optional 是一个类型，它是个枚举，它跟其他任何类型

105
00:05:33,000 --> 00:05:35,400
other type, it just has this interesting behavior, and
都一样，它只是有这些有趣的行为

106
00:05:35,468 --> 00:05:36,501
it's got all the question marks and
所有的问号和感叹号

107
00:05:36,570 --> 00:05:39,070
exclamation points to make all the code look a little
都是为了让代码看起来更简单一点

108
00:05:39,139 --> 00:05:42,407
simpler. Now, there's even other stuff about optionals
现在有一些 Optional 的其他的

109
00:05:42,476 --> 00:05:46,311
that are interesting. Optionals can be chained.
有意思的事情。Optional 可以被链接

110
00:05:46,380 --> 00:05:49,481
Now what does this mean? Well, this is best shown by example.
啥意思呢？额，这最好通过一个例子来展示

111
00:05:49,550 --> 00:05:53,885
So, let's say I have a Optional UILabel like my
假设我有一个类似于我的计算器中的 display

112
00:05:53,954 --> 00:05:57,556
display in the calculator and it's got the text, that's also
的 Optional UILabel。而且它有 text 文本

113
00:05:57,625 --> 00:06:00,859
an optional, Optional String, we all know that. And
那也是一个 Optional，可选字符串

114
00:06:00,928 --> 00:06:04,062
let's say we want to get the hashValue which is just a var
我们想得到 hashValue，也就是一个字符串的变量

115
00:06:04,131 --> 00:06:07,632
on string, which hashes the string, gives you some integer
它哈希这个字符串，给你一个代表它的整数

116
00:06:07,701 --> 00:06:10,401
for it, I want to get that hashValue of what's in
我想得到 display 中的字符串的 hashValue

117
00:06:10,470 --> 00:06:13,938
the display. So then I would probably do some code that
所以我大概会写一些类似于

118
00:06:14,007 --> 00:06:16,842
looks like this, this is probably similar code to what
这样的代码，这很可能和我们在计算器中

119
00:06:16,911 --> 00:06:20,211
we have in our calculator where I've got my display,
得到我的 display 的代码很像

120
00:06:20,280 --> 00:06:24,882
that's my IBOutlet probably that display UILabel?, and
那大概是我的 @IBOutlet display: UILabel?

121
00:06:24,951 --> 00:06:29,321
I'm going go do "if let" here, because I don't want to crash
这里我打算用 if let，因为我不想让程序崩溃

122
00:06:29,390 --> 00:06:30,755
so I don't want to do exclamation points,
所以我不想用感叹号

123
00:06:30,824 --> 00:06:32,524
I'm going to do "if let", so I'm going to say "if let
我想用 if let，所以我打算写如果让

124
00:06:32,593 --> 00:06:35,794
some temporary value equals to the display" (now temp1 is
一个临时变量 temp1 等于 display（现在 temp1 是

125
00:06:35,863 --> 00:06:40,599
the UILabel), and then I say, "if let temp2 = temp1.text",
是 UILabel），然后我写 if let temp2 = temp1.text

126
00:06:40,667 --> 00:06:43,568
I'm sending text to the UILabel and
我正在将文本发送给 UILabel

127
00:06:43,637 --> 00:06:46,037
now I'm getting back a String, not an Optional String, but
现在我得到了一个字符串，不是可选字符串，而是

128
00:06:46,106 --> 00:06:48,707
a String, because I did "if let", then I can finally say,
字符串，因为我用了 if let，最后我写道

129
00:06:48,776 --> 00:06:51,542
then "let x = temp2", which is the String,
let x = temp2.hashValue，来获得字符串的哈希值

130
00:06:51,611 --> 00:06:55,747
the hashValue. Okay, this is a lot of code to have to type to
我们写这么多代码只是为了

131
00:06:55,816 --> 00:07:00,084
just get that dang hashValue, out of that UILabel's text.
获得一个 UILabel 文本那该死的哈希值

132
00:07:00,153 --> 00:07:03,422
With optional chaining, this same code looks like this,
用 Optional Chaining，可选链接

133
00:07:03,490 --> 00:07:05,290
the first line of those two lines.
同样的代码能用第一行表示

134
00:07:05,359 --> 00:07:10,696
"If let x = display?.text?.hashValue,
if let x = display?.text?.hashValue

135
00:07:10,764 --> 00:07:16,568
then do something with x". In that case of course, x will
然后用 x 做一些事情。当然在这种情况下，x 不是

136
00:07:16,636 --> 00:07:20,005
be a non-optional, because I'm doing if let on it.
一个 Optional，因为我用了 if let

137
00:07:20,073 --> 00:07:23,408
If I take the "if" off, and just do "let x =" all that,
如果我将 if 删掉，只写 let x = 的话

138
00:07:23,476 --> 00:07:27,045
then x will be an optional Int. Now, how is this working?
那么 x 将会是个 Optional Int。那么这是什么原理呢？

139
00:07:27,113 --> 00:07:28,547
What's happening is that every time that you have one of
每当你在 Optional

140
00:07:28,616 --> 00:07:31,750
those question marks after an Optional, it's saying,
后面加问号的时候

141
00:07:31,819 --> 00:07:35,620
if this is in the set case, then grab it and keep on
如果它处于已赋值的状态，那么抓取它然后继续

142
00:07:35,689 --> 00:07:39,324
going, send the next thing. If it's in the nil case, then
向后执行，发送下一个东西。如果它处于空的状态

143
00:07:39,393 --> 00:07:42,861
just return nil for this whole expression, this entire line,
整个表达式将返回空，整个一行

144
00:07:42,930 --> 00:07:45,998
boom, it's just gonna return nil. If I'm if letting it,
它仅仅是返回空。如果我用 if let

145
00:07:46,066 --> 00:07:48,933
then obviously the code won't get executed.
那么很显然代码将不会被执行

146
00:07:49,002 --> 00:07:51,269
You can do as many of these as you want in a row, and
在一行中你想写多少写多少，并且

147
00:07:51,338 --> 00:07:55,574
we do this all the time, this optional chaining is going to
我们成天都在做这种事，你的代码中将会

148
00:07:55,642 --> 00:07:58,676
be all over your code, and it makes perfect sense because
大量使用可选链接。并且它很容易理解

149
00:07:58,745 --> 00:08:01,280
again, we're using this question mark and exclamation
因为问号和感叹号

150
00:08:01,348 --> 00:08:04,316
point. Here we happen to use the question mark when we're
我们在访问它时会用

151
00:08:04,385 --> 00:08:07,952
accessing it versus when we're declaring it. That's what it
声明的时候也会用

152
00:08:08,021 --> 00:08:09,621
means to use a question mark when you're accessing it,
这就是访问它时使用问号的含义

153
00:08:09,690 --> 00:08:12,557
it means go get it, and if it's not set,
它的意思是有关联值就去获取

154
00:08:12,626 --> 00:08:14,359
then just return nil from this whole expression,
未赋值那么整个表达式返回空

155
00:08:14,428 --> 00:08:15,661
it will just bail out of the whole thing,
它会保护整个过程

156
00:08:15,729 --> 00:08:18,196
It will never even execute hash value because we'll never
如果当中任何一个为空，它甚至不会执行 hashValue

157
00:08:18,265 --> 00:08:20,366
get down to that end of it, if any of these things are nil.
因为我们不会执行到底

158
00:08:24,471 --> 00:08:26,971
Another cool optional things we can do is optional
我们能用 Optional 做的另一件很酷的事是

159
00:08:27,040 --> 00:08:31,543
defaulting. So what if we had wanted to put a string in our
可选默认值。我们想将一个字符串放到类似于 display

160
00:08:31,612 --> 00:08:35,480
UI label like in our display, but we know that if that
的 UILabel 里面，但如果我们知道那个

161
00:08:35,548 --> 00:08:37,749
string is nil, we don't want to put nil in there because
字符串是空的，我们不想将它放进去

162
00:08:37,818 --> 00:08:40,418
what'll happen to our label if we put nil in as the text?
如果我们将空当成文本放到 label 里面将会发生什么？

163
00:08:40,487 --> 00:08:43,822
It'll collapse down, right, probably most of you saw that.
它将会崩溃，对吧，可能你们中大部分人都已经见识过了

164
00:08:43,891 --> 00:08:44,889
You have to put something in there,
你必须在这里放一些东西

165
00:08:44,958 --> 00:08:47,759
at least a space. So let's say that I want to do that,
至少是个空格。所以让我们来实现这个功能

166
00:08:47,828 --> 00:08:50,829
I want to put space in there if it's nil. This is the code
如果为空的话我想在那儿放一个空格。代码

167
00:08:50,898 --> 00:08:53,565
that it would look like here: I'd have my string, I would
看起来差不多是这样的：我有个字符串

168
00:08:53,634 --> 00:08:57,135
say if the string is not nil, then put it in the display,
如果字符串不是空的，那么将它放到字符串里

169
00:08:57,204 --> 00:09:02,341
otherwise, if it is nil, put space in there. This looks
其他情况下，如果它为空，在这放个空格

170
00:09:02,409 --> 00:09:06,845
a lot cleaner with optional defaulting, which looks like
用可选默认值的话代码会显得很简洁

171
00:09:06,913 --> 00:09:11,616
this, display.text = s ?? " ". That means if s is nil, use
就像这样，display.text = s ?? " "。意思是如果 s 为空

172
00:09:11,685 --> 00:09:15,788
this other thing. It's like the default in case s is nil.
就用另一个东西，也就是 s 为空时的默认值
 
173
00:09:17,191 --> 00:09:20,993
We will use this all the time as well. Everybody got that?
我们也将会一直使用这个东西。所有人都懂了吧？

174
00:09:21,061 --> 00:09:23,862
Just optional defaulting. Alright, so I bring those out
就是给可选提供默认值。好了，我提到的

175
00:09:23,931 --> 00:09:25,463
of the optional world just to highlight them,
只是 Optional 的世界中想再次强调的

176
00:09:25,532 --> 00:09:27,432
because there's a lot in the reading that you're doing
因为你已经阅读过很多关于 Optional 的东西了

177
00:09:27,501 --> 00:09:29,934
about optional, but these are kind of the highlights.
但是这些还是需要强调的

178
00:09:30,003 --> 00:09:32,437
There are a couple more things actually I'll show you later,
实际上之后还有一些我想展示给你们的东西

179
00:09:32,505 --> 00:09:35,707
but basically that's it for optionals. Alright, tuples.
但这基本上就是可选的全部内容了

180
00:09:35,775 --> 00:09:38,743
So I had you skip tuples in reading assignment one, but
下一个，元组。虽然在阅读任务一中跳过了

181
00:09:38,812 --> 00:09:41,947
you'll be reading about them in reading assignment two.
但你们将会在任务二中读到它们 

182
00:09:42,015 --> 00:09:42,848
What is a tuple?
元组是什么？

183
00:09:42,916 --> 00:09:47,886
A tuple is super simple, it's just a grouping of values,
元组非常简单，它只是一组值

184
00:09:47,955 --> 00:09:51,189
and you can use it anywhere you're using a type. What does
你在任何使用类型地方，都可以用元组

185
00:09:51,258 --> 00:09:54,692
a tuple look like? It looks like this. This var here,
元组长啥样呢？它长这个样。这里的变量

186
00:09:54,761 --> 00:09:59,164
this constant, actually x, I'm setting its type to be a tuple
这个常量，就是 x，我将它的类型设置成一个元组

187
00:09:59,232 --> 00:10:04,002
with a string and int and a double, that's its type. A tuple
由 String，Int 和 Double 组成，那就是它的类型

188
00:10:04,071 --> 00:10:06,972
can have any number of things in there, but realistically,
一个元组内可以包含任意多的类型，但是实际上

189
00:10:07,041 --> 00:10:09,908
we probably only have three or four, sometime only two, but
我们大概只会有3或4个，有时候只有俩

190
00:10:09,977 --> 00:10:15,980
it can have any number. I can set x equal to parentheses,
但它可以有无穷多个。我可以使 x 等于一个圆括号

191
00:10:16,049 --> 00:10:19,451
those three, any value of those three types. So here,
这三个，这三个类型的任何值。在这里

192
00:10:19,519 --> 00:10:22,187
I've set it to hello, 5, and 0.85.
我将它设置为 "hello"，5 和 0.85

193
00:10:22,255 --> 00:10:26,591
Now I can get the values out into individual variables by
我可以将值拿出来赋给独立的变量

194
00:10:26,660 --> 00:10:31,496
saying let parentheses three different variable names equal x.
通过 let (三个不同的变量名) = x

195
00:10:31,565 --> 00:10:34,432
And now it will pull out the three different values
现在它将会把这三个不同的值

196
00:10:34,501 --> 00:10:36,968
into the three separate variables, word, number, and
赋给三个分开的变量，word，number 和

197
00:10:37,037 --> 00:10:41,039
value. So it's kind of mirror image there,
value。它在这像一个镜像图片

198
00:10:41,108 --> 00:10:43,141
you can kinda go either, either direction,
你可以向正向或反向的方向走

199
00:10:43,209 --> 00:10:46,511
putting things in or out. We actually, believe it or not,
把东西放进来或拿出去。信不信由你，我们实际上

200
00:10:46,580 --> 00:10:47,912
don't do it that way most of the time,
大多数时候并不这样用

201
00:10:47,981 --> 00:10:52,751
because it is also possible to name the elements of a tuple.
因为命名元组中的元素也是可以的

202
00:10:52,819 --> 00:10:55,987
So here, I define x, same thing, string int double, but
这里我定义的 x 也是 (String, Int, Double)

203
00:10:56,056 --> 00:10:57,456
look, I've named each of them,
但看这儿，我已经命名了它们

204
00:10:57,524 --> 00:11:00,992
I called the string part w, I called the int part i, and
我把 String 部分叫做 w，把 Int 部分叫做 i，

205
00:11:01,061 --> 00:11:04,262
I called the double part v for some reason. Now, I still set
把 Double 部分叫做 v。现在我仍然用和刚才

206
00:11:04,331 --> 00:11:07,833
it equal in exactly the same way, no difference there. But
一样的方法给它赋值，没什么不同。但是

207
00:11:07,901 --> 00:11:10,735
now I don't need to pull it out into separate variables.
现在我不需要将其拉出到单独的变量中

208
00:11:10,804 --> 00:11:15,407
I can just say x.w and get the w, the first component of it.
我可以只写 x.w 来得到 w，也就是它的第一部分

209
00:11:15,476 --> 00:11:18,510
You see that? This is how we do tuples, with names.
看懂了吧？这就是通过命名来使用元组的方法

210
00:11:18,579 --> 00:11:21,446
I strongly recommend you almost always use
我强烈推荐你在几乎任何情况下都用

211
00:11:21,515 --> 00:11:24,183
names with tuples. It's just a little easier to read,
命名的方法使用元组。它使代码读起来更简单

212
00:11:24,251 --> 00:11:27,685
clearer to say what your intent is as a programmer.
作为一个程序员更清楚地表明你的意图

213
00:11:27,754 --> 00:11:28,654
Because those names
因为元组中

214
00:11:30,423 --> 00:11:32,590
of the parts of the tuple can have good variable names.
每个部分都可以有很好的变量名

215
00:11:32,659 --> 00:11:35,927
You're gonna see in your programming assignment number
你们将会在编程任务二中看到

216
00:11:35,996 --> 00:11:39,564
2, I'm gonna have you write a function that returns a tuple,
我将让你们写一个返回元组的函数

217
00:11:39,633 --> 00:11:43,568
and it's going to specify the names of the parts. Now even
并且元组的部分必须具体命名。现在即便

218
00:11:43,637 --> 00:11:46,605
if you name them, like we have x with the named ones,
你已经命名了他们，就像我们用 x 命名他们

219
00:11:46,674 --> 00:11:50,075
you can still do that thing where you just say, let (word,
你依然可以用 let (word,

220
00:11:50,143 --> 00:11:53,211
num, val) equal x, and it'll still pull it out into
num, val) = x，它依然会将其拉出到

221
00:11:53,280 --> 00:11:56,448
individual ones, so naming them doesn't stop you from
单独的变量中，所以命名他们不会阻止你

222
00:11:56,517 --> 00:11:59,751
pulling them out by individual variable, if you want.
将其拉出到单独的变量中，如果你想这么做的话

223
00:11:59,820 --> 00:12:03,254
Also, in tuples, you can always put underbar for
还有，在元组中，你无论何时都可以在

224
00:12:03,323 --> 00:12:07,125
any of the names, like here I could say let word_ val or
任何地方放下划线，就像这里我可以写

225
00:12:07,193 --> 00:12:11,096
let word,_, val equal x, and then I would get word and
let (word, _, val) = x，这样我可以得到 word 和

226
00:12:11,165 --> 00:12:15,367
val into individual variables, and I would just ignore that
val 的值，无视掉中间那个

227
00:12:15,435 --> 00:12:19,471
middle one. Underbar in Swift always kinda means ignore
划线在 Swift 中意味着无视它

228
00:12:19,539 --> 00:12:22,341
that, I'm not interested in that particular thing.
我不在乎它的细节

229
00:12:22,409 --> 00:12:25,477
We've already seen this with function parameters when we
我们已经在当我们想无视函数参数

230
00:12:25,546 --> 00:12:29,048
want to ignore the external name of a function parameter.
的外部变量名时见过它了

231
00:12:29,116 --> 00:12:30,682
Alright, so using tuples that return values,
好了，用元组返回数据

232
00:12:30,751 --> 00:12:33,352
like I said, you're gonna see this in the homework.
就像我写的这样，你们将会在作业中看到这个

233
00:12:33,420 --> 00:12:36,354
Nothing special here. It's a type like any other type, so
没啥特别的东西。它跟其他任何一种类型都一样，所以

234
00:12:36,423 --> 00:12:39,057
it can be the return type of a function. So, this is how you
它可以作为函数的返回类型。所以，这就是你们让

235
00:12:39,126 --> 00:12:41,894
can have a function that returns multiple values.
一个函数返回多个值的方法

236
00:12:41,962 --> 00:12:44,696
In some languages, it's very difficult to do this.
在某些语言中，这一点很难做到

237
00:12:44,765 --> 00:12:46,998
You have to create a structure or something to return.
你必须创建一个结构体或其他东西来返回

238
00:12:47,067 --> 00:12:48,366
However, it's very, very, very easy in Swift.
然而，在 Swift 中这非常简单

239
00:12:48,435 --> 00:12:50,769
You literally just do this. And
你真的只需要用元组

240
00:12:50,838 --> 00:12:54,273
when you get the value that comes back from that function,
并且当你函数的返回值时

241
00:12:54,341 --> 00:12:58,343
you just access the elements by name. Notice that when I
你可以用名字来访问元素。注意在代码中的 getSize()

242
00:12:58,411 --> 00:13:01,747
returned it in my code there in getSize, I didn't have to
当我返回它时，我不需要

243
00:13:01,816 --> 00:13:04,115
give the names; I could if I wanted to,
把名字带上；如果我想我也可以带上

244
00:13:04,184 --> 00:13:07,585
I could have said return weight:150, height:, but
我可以写 return (weight: 150, height: xxx)

245
00:13:07,654 --> 00:13:11,390
I decided, eh, I'm just gonna return the values. Okay,
但是我决定，额，我只想返回数值

246
00:13:11,458 --> 00:13:15,994
another thing: range, range is an important little
另一个内容：Range。Range 是 Swift 中重要的

247
00:13:16,063 --> 00:13:21,165
struct in Swift: all that it represents is two end points.
结构体：它代表两个端点

248
00:13:21,234 --> 00:13:24,536
So a range is useful for, for example, a selection of text,
所以举个例子， Range 适用于文本的选择

249
00:13:24,604 --> 00:13:27,806
where the selection starts and where the selection ends.
选择开始的地方和选择结束的地方

250
00:13:27,874 --> 00:13:32,610
It's also good for a sub-slice of an array. If you've got
它也很适合分割一个数组。如果你有一个

251
00:13:32,679 --> 00:13:35,180
array of 100 elements, you might want the 15th to
有100个元素的数组，你可能想要其中从第15个到

252
00:13:35,248 --> 00:13:38,250
the 40th one, so you could specify that range, 15 to 40.
第40个这一段，你可以写一个 Range，从15到40

253
00:13:38,319 --> 00:13:41,086
So range is this really simple little struct, which kind of
所以 Range 是个很简单的结构体，看起来

254
00:13:41,155 --> 00:13:43,655
looks like this. I say kind of, because it's a little more
就像这样。我说“像”，因为它比这还更

255
00:13:43,723 --> 00:13:45,991
complicated than this, but it basically looks like this.
复杂一点，但它看起来大概就是这样的

256
00:13:46,059 --> 00:13:49,061
It's a generic type like array because of course, you can
这是个像数组的泛型，因为当然，你可以

257
00:13:49,129 --> 00:13:52,097
have a range of ints. You could have a range of floats.
有一个整数的 Range。你可以有一个浮点数的 Range

258
00:13:52,166 --> 00:13:55,200
You could have a range of strings even. Okay, so
你甚至可以有一个字符串的 Range

259
00:13:55,269 --> 00:13:57,836
that T right there could be float, float, int,
所以那个 T 可以是浮点数，整数，字符串

260
00:13:57,905 --> 00:14:01,139
string. T is restricted a little bit, and I haven't
T 有一些限制，我还没有

261
00:14:01,208 --> 00:14:03,374
really talked about how you restrict a generic type.
真正讲到如何限制一个泛型

262
00:14:03,443 --> 00:14:04,610
But that T is restricted,
但这个 T 被限制了

263
00:14:04,678 --> 00:14:07,746
and it has to be what's called comparable. That's because
它必须是 Comparable，可比较的

264
00:14:07,815 --> 00:14:10,481
range needs to make sure that the start index is less than
那是因为 Range 需要确保起点小于终点

265
00:14:10,550 --> 00:14:13,619
the end index. That's part of what a range is defined to be.
这是 Range 定义的一部分

266
00:14:13,687 --> 00:14:16,354
So that T has to be something that can be compared
所以 T 必须是可以比较的东西

267
00:14:16,423 --> 00:14:19,258
to see if the start index is less than the end index,
查看开始端点是否小于终止端点

268
00:14:19,326 --> 00:14:23,495
minor thing there. So, for example, a range of int
这是个细节。所以，举个例子，整数的 Range

269
00:14:23,563 --> 00:14:25,964
would be great for specifying a range in an array,
很适合具体说明数组中的 Range

270
00:14:26,032 --> 00:14:28,667
cuz an array is indexed by integers, right, starting at 0
因为数组的下标是整数，对吧

271
00:14:28,735 --> 00:14:32,170
and going up to the number of things in the array.
从 0 开始，一直到小于数组长度的整数

272
00:14:32,239 --> 00:14:37,643
Now there are other more powerful, more capable ranges,
还有一些更强大，更好用的 Range

273
00:14:37,712 --> 00:14:41,113
like CountableRange. A CountableRange is
例如 CountableRange，也是个 Range

274
00:14:41,181 --> 00:14:43,916
just like a range, except for that you can count through
但特别之处在于你可以通过

275
00:14:43,984 --> 00:14:47,485
intermediate values between the start and the end.
起始端点和终止端点的中间的值计数

276
00:14:47,554 --> 00:14:50,856
Okay, it's like a range of ints. A CountableRange means
它看起来就像整数的 Range

277
00:14:50,924 --> 00:14:54,092
the begin point and end point and one point each.
CountableRange 包含了起点，终点，以及中间每个点

278
00:14:54,160 --> 00:14:57,429
Now as you stride through that range, it depends on what
遍历 Range 的过程因值的具体类型而不同

279
00:14:57,498 --> 00:15:00,565
the type is. Striding through a range of ints is different
遍历整数 Range 和

280
00:15:00,634 --> 00:15:03,735
then striding through a range of floats, or striding through
遍历浮点数

281
00:15:03,804 --> 00:15:06,471
a range of strings. There's a little difference there, and
或者是字符串的 Range 都不同

282
00:15:06,539 --> 00:15:07,539
we'll talk about that in a minute.
具体不同之处，我很快会讲到

283
00:15:08,809 --> 00:15:10,508
There's a special syntax for
Range 的有个特别的语法

284
00:15:10,577 --> 00:15:15,581
doing range, which is "dot dot less-than" or "dot dot dot".
也就是 ..< 或者 ...

285
00:15:15,649 --> 00:15:20,018
Dot Dot Less-than means that you put the start index and
..< 的用法是你将开始点

286
00:15:20,087 --> 00:15:22,988
the end index on either side of the dot dot less than.
与终止点放到 ..< 的两侧

287
00:15:23,056 --> 00:15:26,457
And that means go from the start index to the end index,
那意味着从开始点到终止点

288
00:15:26,526 --> 00:15:29,428
but don't include the end index, not inclusive of it,
但不包括终止点，不包括它

289
00:15:29,497 --> 00:15:32,731
and the dot dot dot includes both ends. So for
... 同时包括两个端点

290
00:15:32,800 --> 00:15:36,067
example, in an array, let's have an array of four strings,
举个例子，在数组中，有四个字符串

291
00:15:36,136 --> 00:15:39,370
a, b, c, d, and let's say that I want to get the c and
a b c d。假设我想把 c 和

292
00:15:39,439 --> 00:15:43,742
the d out of there, I can say array sub, (just
d 拿出来，我可以写 array[]

293
00:15:43,811 --> 00:15:48,947
like how I can say array sub 5 or array sub 3 is the fourth
就像我可以写 array[5]，或 array[3]（数组中第四个）

294
00:15:49,015 --> 00:15:52,350
index of the array), I can also specify a range and
我也可以写一个 Range 作为下标

295
00:15:52,419 --> 00:15:55,654
get a sub array, a slice of the array, it's called. So
来得到一个子数组，也就是数组中的一部分

296
00:15:55,722 --> 00:15:59,290
I can say 2...3, which means index 2 in the array,
我可以写 2...3，意思是数组中第三个元素

297
00:15:59,359 --> 00:16:03,161
which is c because a is index 0, b is index 1, c is index 2,
也就是 c，因为 a 是[0]，b是[1]，c是[2]

298
00:16:03,230 --> 00:16:07,032
dot dot dot index 3, which is the d inclusive, cuz it's dot
...3，也就包括了 d，因为 ... 是闭区间

299
00:16:07,101 --> 00:16:10,135
dot dot. And then the less than 1 would be exclusive,
有小于号的那个是不包括的

300
00:16:10,203 --> 00:16:13,672
so that's why the d wouldn't be included in that one. So
所以这就是为什么在这一个 d 不会被包括。

301
00:16:13,740 --> 00:16:16,508
see how I'm using a range to get a sub slice of an array,
我使用 Range 来得到数组的一部分的方法

302
00:16:16,577 --> 00:16:18,977
that's kind of cool. By the way,
很酷吧。顺带一提

303
00:16:19,046 --> 00:16:22,314
if you say give me the array from 6...8,
如果你写给我这个数组的 6...8

304
00:16:22,382 --> 00:16:25,016
that's going to crash at run time with an array index out
在运行时将会崩溃，因为数组下标

305
00:16:25,085 --> 00:16:28,053
of bounds because this array only has four elements. So
越界，因为这个数组只有四个元素。所以

306
00:16:28,121 --> 00:16:32,824
just because I'm accessing this subscripting with a range
即便是用 Range 而非数字来访问下标时

307
00:16:32,892 --> 00:16:35,827
instead of with a number, it still has to be in bounds.
它依然需要在边界之内

308
00:16:35,896 --> 00:16:38,797
And then if I say array[4...1],
然后如果我写 array[4...1]

309
00:16:38,866 --> 00:16:42,233
that also will crash at run time, because the range
运行时一样会崩溃，因为 Range

310
00:16:42,302 --> 00:16:44,970
is going to look at that and say I can't create a range
会看着它说我不能创建一个

311
00:16:45,039 --> 00:16:47,272
where the start value is greater than the end value,
开始点大于终止点的 Range

312
00:16:47,341 --> 00:16:50,776
can't be a backwards range, that's why that type like
Range 不能是前后颠倒的。因此必须是可比较的

313
00:16:50,844 --> 00:16:53,278
int has to be comparable, of course you can compare ints.
类似于整数那样的（当然你可以比较整数）


314
00:16:54,781 --> 00:16:59,718
One thing very important to understand: a string,
注意，理解一件事非常重要

315
00:16:59,787 --> 00:17:04,089
a subrange of a string is not a range of ints.
获取字符串的子串不是通过整数 Range

316
00:17:05,859 --> 00:17:08,093
You might think it is, right, I've got this string,
你们可能觉得是，我得到了这个字符串

317
00:17:08,162 --> 00:17:10,629
100 characters, you might think strings sub 15 to 40
有 100 个字符，你可能会想 string[15..<40]

318
00:17:10,697 --> 00:17:12,998
would be the 15th character to the 40th. And
就是从第 15 个字符到第 40 个

319
00:17:13,066 --> 00:17:17,068
it's not: a string subrange is a range of string.index,
但并不是：字符串的子串是 String.Index 的 Range

320
00:17:17,137 --> 00:17:18,971
which is a different little data type, and
是个稍微有点不同的数据类型

321
00:17:19,039 --> 00:17:20,806
I'm going to talk all about that in a few slides.
我将会在接下来的幻灯片中讲到它

322
00:17:20,875 --> 00:17:23,541
But I just want to make it really clear,
我只想说明一点

323
00:17:23,610 --> 00:17:27,846
that it is possible to say string subrange start..<end,
写 string[start..<end] 是可以的

324
00:17:27,914 --> 00:17:31,716
but start and end are not ints, they're string.indexes,
但是 start 和 end 不是整数，他们是 String.Index

325
00:17:31,785 --> 00:17:35,587
and we'll see how that works. If the type
我们将会看到它是如何工作的。如果你用 ..<

326
00:17:35,656 --> 00:17:38,089
of the range that you create with dot dot less than or
或者 ... 创建的 Range 的类型

327
00:17:38,158 --> 00:17:41,793
dot dot dot, if that type is an int, (actually,
如果那个类型是整数

328
00:17:41,861 --> 00:17:44,863
if it's strideable by int, they can be strided by int so
也就可以作为整数遍历的

329
00:17:44,932 --> 00:17:48,000
it's not gonna be float, but I'm not really prepared to
那自然不会是浮点数。但我还没准备好

330
00:17:48,068 --> 00:17:52,771
talk to you about strideable), but if the range has
给你们讲 Strideable。总之如果 Range 的

331
00:17:52,840 --> 00:17:57,008
ints on either end, so it's a range from 2 to 7, for
任意一个端点是整数，例如一个从 2 到 7 的 Range

332
00:17:57,077 --> 00:18:00,145
example, then it automatically creates that countable range,
它会自动创建为一个 CountableRange

333
00:18:00,214 --> 00:18:03,248
that more capable range.
那个更好用的 Range

334
00:18:03,317 --> 00:18:06,485
That range then becomes what's called a sequence, And
那个 Range 之后会变成一个叫做 Sequence（序列）的东西

335
00:18:06,554 --> 00:18:10,188
sequences can be iterated through or enumerated, and
Sequence 可以被迭代或者罗列

336
00:18:10,257 --> 00:18:14,726
the way you do that is with "for in", so Swift's for
实现方法是用 for in 语句

337
00:18:14,795 --> 00:18:19,430
statement, this is the only one there is. It's called
也就是 Swift 中唯一的 for 语句

338
00:18:19,499 --> 00:18:24,069
"for in" and all it ever means is, I want to go and enumerate
for in 的意思是，我想要遍历这个 Sequence

339
00:18:24,138 --> 00:18:28,206
all the values of a sequence. I'm going to talk about what
中所有的值。我打算讲讲什么东西

340
00:18:28,275 --> 00:18:31,009
things that can be sequenced. Countable range is 1,
可以成为 Sequence。CountableRange 可以

341
00:18:31,078 --> 00:18:33,044
because if an int goes from 0 to 7, and
比如 0 到 7 的整数 CountableRange

342
00:18:33,113 --> 00:18:36,815
it's a countable range, then it can go 0, 1, 2, 3, 4, 5, 6,
自然可以遍历 0 1 2 3 4 5 6 7

343
00:18:36,884 --> 00:18:42,353
7. Arrays are sequences, sequences of their elements.
数组是 Sequence，由它元素构成的序列

344
00:18:42,422 --> 00:18:45,591
So you can "for in" through an array. Dictionaries are also,
所以你可以用 for in 遍历一个数组。字典也可以

345
00:18:45,659 --> 00:18:49,161
and we'll see that a little later. So here's how you do
过一会儿我们就会看到。这相当于 C 语言

346
00:18:49,230 --> 00:18:54,132
a normal C-like for loop, for (i = 0; i < 20; i++).
for (i = 0; i < 20; i++) 这个 for 循环语句

347
00:18:54,201 --> 00:18:56,901
You cannot do that in Swift, that syntax simply doesn't
你在 Swift 中不能这样写，这个语法已经

348
00:18:56,970 --> 00:19:01,807
exist. Instead you would say for i in the range 0..<20,
不存在了。作为替代你应该写 for i in 0..<20

349
00:19:01,875 --> 00:19:04,509
because notice I said it's less than 20, not less than or
注意我写的是小于 20，不是小于或

350
00:19:04,578 --> 00:19:10,448
equal to 20, so 0..<20 means go through that. And so
等于 20，所以 0..<20 意思是遍历它

351
00:19:10,517 --> 00:19:12,984
that little block of code is going to be executed once for
这一小块儿代码将被执行

352
00:19:13,053 --> 00:19:17,155
0, 1, 2, 3, 4, all the way up to number 19, so
0 1 2 3 4 直到 19

353
00:19:17,224 --> 00:19:19,057
that's same thing as what you see there.
那和你们在那里看到的一样

354
00:19:19,126 --> 00:19:21,860
Now what about floats? Floats are a little weird.
那浮点数呢？浮点数稍微有点奇怪

355
00:19:21,929 --> 00:19:28,066
What if I wanted to do for (i = 0.5; i <= 15.25; i += 0.3).
我该如何实现 for (i = 0.5; i <= 15.25; i+=0.3)

356
00:19:28,135 --> 00:19:32,905
Whoa, how am I gonna do that? I can't, for
噫，我该咋办呢？我不能写

357
00:19:32,973 --> 00:19:38,076
example, say for i in 0.5...15.25.
for i in 0.5...15.25

358
00:19:38,145 --> 00:19:42,447
How does it know to go by 0.3? And the answer is, it doesn't.
它怎么知道每次加 0.3 呢？答案是，不能

359
00:19:42,516 --> 00:19:47,219
In fact, a range like that, 0.5...15.25 is not a countable
事实上，像 0.5...15.25 这样的只是 Range

360
00:19:47,287 --> 00:19:50,923
range, it's just range. It only knows the start and end,
不是 CountableRange，它只知道起点与终点

361
00:19:50,991 --> 00:19:53,725
it knows nothing about what's in between, so
它对中间一无所知，所以

362
00:19:53,794 --> 00:19:56,995
it cannot be a sequence, it can't be for in over. But
它不能作为一个序列遍历

363
00:19:57,064 --> 00:20:01,567
luckily, there's this great global function called stride.
幸运的是，有一个叫做 stride 的全局函数

364
00:20:01,635 --> 00:20:04,636
Stride takes a from and a to, or a through,
stride 接受一个 from，和一个 through 或者 to

365
00:20:04,704 --> 00:20:06,939
(depending whether you wanna go through to the end,
取决于你是想遍历到最后

366
00:20:07,008 --> 00:20:09,341
or just to to and not including it), and
还是仅仅是到那儿但不包括它

367
00:20:09,409 --> 00:20:11,476
a by, which is, what it's going to step by.
和一个 by，意思是，每一步加上的数值大小

368
00:20:11,545 --> 00:20:15,781
So here, I say stride from 0.5 through 15.25,
所以在这，我写 stride(from: 0.5, through: 15.25

369
00:20:15,849 --> 00:20:19,351
because I want less than or equal to, by 0.3, and
因为我想小于或等于，by: 0.3)

370
00:20:19,419 --> 00:20:23,254
that's gonna create a new object, it's a CountableRange.
那会创建一个新对象，它是个 CountableRange

371
00:20:23,323 --> 00:20:26,024
Now it's a special CountableRange, it knows
它是一个特别的 CountableRange，它知道

372
00:20:26,093 --> 00:20:30,261
how to count from 0.5 to 15.25 by that 0.3 step. You
如何从 0.5 每隔 0.3 数到 15.25

373
00:20:30,330 --> 00:20:32,797
don't need to worry about how it implements it, Stride just
你不需要关心它是如何实现的，stride 只是

374
00:20:32,866 --> 00:20:35,633
creates you a CountableRange. Actually this will be called
给你创建了个 CountableRange。实际上它被称作

375
00:20:35,702 --> 00:20:39,204
a ClosedCountableRange because it counts through to the end,
ClosedCountableRange，因为它遍历到最后

376
00:20:39,273 --> 00:20:42,374
so it's a dot dot dot kind of range instead of a dot dot
所以它是个 ... 类的 Range，而不是 ..<

377
00:20:42,442 --> 00:20:45,978
less than kind of range. So I have a CountableRange, and
所以我有了 CountableRange，并且

378
00:20:46,046 --> 00:20:49,648
it's a sequence, so I can for in it, so I say for i in.
它是个序列，所以能用 for in 了：for i in

379
00:20:49,717 --> 00:20:53,451
Stride, I'd probably say for f in, or even better than f or
stride，我可能会用 for f in，或者比 f 或 i 更好的名字

380
00:20:53,520 --> 00:20:56,688
i. A lot of times, by the way, on my slides, I'm gonna use
顺带一提，为了放进幻灯片里

381
00:20:56,756 --> 00:20:59,457
variables like i or x or d because I want it to fit on my
我会用类似 i 或 x 的变量名

382
00:20:59,526 --> 00:21:02,594
slide, I don't want it to be wrapping. It's hard for you to
我不想让代码被换行。如果幻灯片上的代码

383
00:21:02,663 --> 00:21:05,264
read the slide if the code's always wrapping around, so
到处都在换行你们读起来会很难受，所以

384
00:21:05,332 --> 00:21:07,799
just because you see me using i and d and f doesn't mean
你们不要因为看到我用 i 和 d 还有 f

385
00:21:07,868 --> 00:21:10,401
that's license to have those kind of terrible names for
就以为可以给你们的变量起这么

386
00:21:10,470 --> 00:21:14,773
your variables. You need to have meaningful names. So
糟糕的名字。你需要起有意义的名字。所以

387
00:21:14,842 --> 00:21:16,274
that's how for in works here,
for in 就是这样用的

388
00:21:16,343 --> 00:21:18,076
because stride is gonna return a CountableRange,
因为 stride 会返回一个 CountableRange

389
00:21:18,145 --> 00:21:20,779
ClosedCountableRange in this case. So
在这种情况下是 CloseCountableRange

390
00:21:20,848 --> 00:21:25,450
that's how you do your standard for loops from C.
这就是实现 C 中的标准 for 循环的方法

391
00:21:25,518 --> 00:21:29,587
Alright, let's talk about the data structures in Swift.
好了，让我们谈谈 Swift 中的数据结构

392
00:21:29,656 --> 00:21:31,823
You've already learned about three of the four of them,
你们已经学了它们四个中的三个了

393
00:21:31,891 --> 00:21:37,296
which are classes, structures, and enums. In our lecture,
分别是类，结构体，枚举。在课上

394
00:21:37,365 --> 00:21:39,130
we already did all three of those things.
这三种东西我们都做过了

395
00:21:39,199 --> 00:21:41,233
We had a class, which is our view controller subclass.
我们做过类，就是我们的 ViewController 的子类

396
00:21:41,302 --> 00:21:42,634
We had a struct, which is our calculator brain.
我们做过结构体，就是我们的 CalculatorBrain

397
00:21:42,703 --> 00:21:45,304
And we had enum, which was our operation.
并且还做过枚举，就是我们的 Operation

398
00:21:46,607 --> 00:21:49,407
The fourth one is protocols, and
第四个是 protocol，协议

399
00:21:49,476 --> 00:21:51,776
I'm not gonna talk about that until next week or
直到下个星期或者下个星期之后

400
00:21:51,845 --> 00:21:54,446
even the week after. Protocols are super, duper important,
我才会讲到它。协议是非常重要的

401
00:21:54,515 --> 00:21:56,314
I don't want to make it sound like they're not important,
我不想让它们听起来似乎它们不重要的样子

402
00:21:56,383 --> 00:21:58,817
But they're new to a lot of you, and so I'm gonna try and
但它对于你们大部分人来说是十分陌生的，所以我觉得

403
00:21:58,886 --> 00:22:01,119
ease you in with these ones that are more familiar,
先介绍你们更熟悉的这三个

404
00:22:01,188 --> 00:22:03,855
although different in Swift probably than what you're used
尽管在 Swift 中或多或少有些不同

405
00:22:03,924 --> 00:22:06,258
to, they're still more familiar to you.
但相较而言你还是更熟悉它们的

406
00:22:06,326 --> 00:22:09,594
Let's just review quickly these three structs and what's
这里我们就快速复习一下这三块儿内容以及他们的

407
00:22:09,663 --> 00:22:13,665
the same and different about them. So what's the same?
相同点与不同点。所以相同点是啥呢？

408
00:22:13,733 --> 00:22:14,599
They're declared very,
它们的声明非常

409
00:22:14,668 --> 00:22:16,601
very similar: they have different key word, but
非常相似：它们有不同的关键字，但

410
00:22:16,670 --> 00:22:17,869
they're almost exactly the same.
它们几乎是相同的

411
00:22:17,938 --> 00:22:20,405
The only difference really is a class can specify a super
唯一的不同是类可以指明它的父类

412
00:22:20,473 --> 00:22:23,675
class, otherwise they're declared exactly the same.
除此之外他们的声明完全相同

413
00:22:23,744 --> 00:22:26,611
They can all have properties and functions, So,
它们都可以有属性和函数，因此

414
00:22:26,680 --> 00:22:30,015
they're all very similar in that way. The only thing here
如此看来它们都非常相似。唯一一件事

415
00:22:30,084 --> 00:22:34,452
is that there cannot be any stored properties in an enum.
就是枚举中不能有储存属性

416
00:22:34,521 --> 00:22:37,956
Enum keeps any data it has in associated values, so it can't
枚举把它的数据保存在关联值中，所以它不能

417
00:22:38,025 --> 00:22:41,025
have any stored properties, but it can have computed
有任何储存属性，但是它可以有计算

418
00:22:41,094 --> 00:22:44,930
properties and they certainly all can have functions.
属性并且它们当然都可以有函数

419
00:22:44,998 --> 00:22:47,532
Another thing that's very similar is they can all
还有很相似的一点是除了枚举它们

420
00:22:47,601 --> 00:22:50,001
have initializers except enums. Enums don't need
都能初始化。枚举（注：一般）不需要

421
00:22:50,070 --> 00:22:52,571
an initializer cuz you just say the case you want, but
因为你可以直接说明你想要的情况

422
00:22:52,640 --> 00:22:56,441
structs and classes have initializers. Okay, so
结构体和类一般都有初始化

423
00:22:56,510 --> 00:22:58,543
that's the same. Now what are the differences?
这就是相同点。不同点是啥呢？

424
00:22:58,612 --> 00:23:01,880
Well of course, inheritance is a big difference for classes.
当然了，继承是类的一个很大的不同点

425
00:23:01,948 --> 00:23:05,784
Classes have inheritance. Structs and enums do not. But
类有继承，结构体和枚举没有。但是

426
00:23:05,853 --> 00:23:08,820
the most important difference, which I mentioned last time,
最主要的不同点，是我上次提到的

427
00:23:08,889 --> 00:23:12,857
is that structs and enums are value types, and
就是结构体和枚举是值类型

428
00:23:12,926 --> 00:23:16,194
classes are reference types. So let's go into that and talk
而类是引用类型。让我们深入讲解

429
00:23:16,262 --> 00:23:18,096
about it just a little more. It's so important, I'm gonna
一下这个问题。这很重要，我打算


430
00:23:18,165 --> 00:23:22,534
talk about it again. A value type, what does that mean?
把它再讲一遍。值类型是什么意思？

431
00:23:22,602 --> 00:23:26,404
It means that it's copied when you pass it as an argument
它的意思是当你把它作为参数传送它时它被复制了

432
00:23:26,473 --> 00:23:27,906
It's copied, even if you just assign it to another variable,
甚至如果你仅仅是把它

433
00:23:27,907 --> 00:23:29,340
to a function.
分配给其他变量或是函数都会拷贝

434
00:23:29,410 --> 00:23:33,445
it gets copied. If you assign it to a let, it's immutable,
如果将它分配给一个 let，它是不可改变的

435
00:23:33,514 --> 00:23:36,314
that's very important to understand. If you assigned
理解这一点很重要。如果你分配

436
00:23:36,383 --> 00:23:40,785
a value type to a let, using let x equal that thing,
一个值类型给 let，用 let x = 那个东西

437
00:23:40,854 --> 00:23:44,155
you just made it immutable, no matter how complicated it is.
不管它有多复杂，你已经使它不可改变了

438
00:23:44,224 --> 00:23:45,890
If it's an array or dictionary,
如果它是个数组或字典

439
00:23:45,959 --> 00:23:49,261
you can't add any elements. If it's a calculatorBrain,
你不能增加任何元素。如果它是 CalculatorBrain

440
00:23:49,329 --> 00:23:52,130
it means you can't call any of its mutable functions, So
你将不能调用它的任何可变的函数，所以

441
00:23:52,199 --> 00:23:55,800
you can't do perform operation on it. Now in assignment two,
你不能对它进行操作。在任务二中

442
00:23:55,869 --> 00:23:58,704
I'm gonna have you add a method to the calculator brain
我打算让你们给 CalculatorBrain 增加一个方法

443
00:23:58,772 --> 00:24:01,539
that is gonna let you use the calculator brain when it's
那使你们在当 CalculatorBrain 是不可改变的时候

444
00:24:01,608 --> 00:24:04,843
immutable, which is kinda cool. You still wouldn't be
使用它，这很酷。你依然不能

445
00:24:04,912 --> 00:24:07,545
able to perform operation but you can be able to something
操作它但是你可以做一些重要的

446
00:24:07,614 --> 00:24:12,350
very important, immutably. Now because of this, this kind of
不改变就能完成的事情。因此，为了实现值类型的

447
00:24:12,419 --> 00:24:15,487
copy-on-write behavior of value types, you must,
写入时复制的行为，你必须

448
00:24:15,556 --> 00:24:18,957
of course, mark all the functions that are going to
标记所有改变值的函数为 mutating

449
00:24:19,026 --> 00:24:23,094
modify it as mutating. And that's how the Swift knows,
这是为了 Swift 知道

450
00:24:23,163 --> 00:24:27,299
"Oops, I've gotta make a copy of this, an actual real copy,
“哦，我需要实际拷贝它，得到一个真正的副本

451
00:24:27,368 --> 00:24:31,135
if someone writes to it". Now a reference class is pretty
如果有人往它里面写数据的话。”引用类型是很

452
00:24:31,204 --> 00:24:34,639
different in that it gets stored in the heap somewhere
不同的，它被储存在一个堆中

453
00:24:34,708 --> 00:24:37,909
with a pointer to it, and when you pass it around to
有一个指针指向它，当你把它传送到

454
00:24:37,978 --> 00:24:41,713
a function or to assign it to another variable or something
函数中或将它分配给另一个变量之类的东西时

455
00:24:41,782 --> 00:24:46,618
like that, you're just passing a pointer around to it.
你只是在传送指向它的指针

456
00:24:46,687 --> 00:24:51,089
Now, by the way, when you say, let x equal a reference type,
现在，顺带一提，当你写 let x = 一个引用类型时

457
00:24:51,158 --> 00:24:54,626
you can still send it messages that will mutate it.
你依然可以给它发送使它转变的信息

458
00:24:55,996 --> 00:24:58,764
All you're saying is the pointer can't change, but
虽然指针是不能改变的，但是

459
00:24:58,833 --> 00:25:01,533
what it points to can always be changed.
指针指向的东西在任何时候都能改变

460
00:25:01,601 --> 00:25:05,137
Now reference types are what you're used to.
引用类型是你们习惯的

461
00:25:05,205 --> 00:25:08,974
Most languages that have object-oriented reference
大部分语言都有面向对象的引用类型

462
00:25:09,043 --> 00:25:15,213
types. Reference types are a little bit Wild West- I
引用类型有点狂野

463
00:25:15,282 --> 00:25:17,816
don't have time to teach you this, I hope you'll get to see
我没时间给你们讲这个，我希望你们

464
00:25:17,885 --> 00:25:19,651
this sometime in your career at Stanford, but
在斯坦福的时光里可以接触它

465
00:25:19,720 --> 00:25:21,820
there is a different way of thinking about programming
还有一种不同的编程思想，它与你们之前

466
00:25:21,888 --> 00:25:23,988
than you're used to: it's called functional programming.
接触到的不同：它叫做函数式编程

467
00:25:24,057 --> 00:25:25,089
How many people have heard the phrase,
有多少人曾经听说过这个词

468
00:25:25,158 --> 00:25:29,227
functional programming? So about half of you. The idea
函数式编程？有一半左右。函数式编程

469
00:25:29,296 --> 00:25:31,663
of functional programming is: you don't want this Wild West
的思想是：你不想要这样的狂野

470
00:25:31,732 --> 00:25:34,599
where you've got these objects with multiple people pointing
你有这些有多人指向它们的对象

471
00:25:34,668 --> 00:25:37,936
at them, any of whom could modify it at any time.
它们中任何一个在任何时间都能修改它

472
00:25:38,004 --> 00:25:41,105
That leaves you open to a lot of difficulty in verifying
这给你核实你的程序的正确性

473
00:25:41,174 --> 00:25:42,975
the correctness of your program.
带来了不小的困难

474
00:25:43,043 --> 00:25:46,278
Whereas if you have a lot of objects that are immutable,
然而如果你有一大堆不可改变的对象

475
00:25:46,346 --> 00:25:49,715
you know they can't change, and their APIs are basically
你知道它们不可能被改变，并且它们的 API 基本上

476
00:25:49,783 --> 00:25:52,718
like mathematical functions where data goes in and
类似于数学函数，数据输入后

477
00:25:52,786 --> 00:25:55,520
predictable data comes out, because there's
可预计的数据输出

478
00:25:55,588 --> 00:25:59,291
not all this side-effecting, data-effecting other objects
因为不会受到其它的数据影响

479
00:25:59,359 --> 00:26:02,194
that someone else is pointing to in all this.
也不会存在被多个指针引用的情况

480
00:26:02,262 --> 00:26:04,595
It's this really well-contained little thing.
这是个非常好的东西

481
00:26:04,664 --> 00:26:08,433
Now iOS was not developed with functional programming in mind
iOS 完全不是按函数式编程开发的

482
00:26:08,502 --> 00:26:11,603
at all. But the people who invented Swift,
但是发明 Swift 的这群人

483
00:26:11,671 --> 00:26:15,074
they were thinking about functional programming, So
它们考虑到了函数式编程，所以

484
00:26:15,142 --> 00:26:17,009
you can kind of mix a lot of the elements of
如果你正在开发一款 iOS 应用程序

485
00:26:17,077 --> 00:26:19,244
functional programming into your application,
你可以把函数式编程的元素

486
00:26:19,312 --> 00:26:22,080
if you're building an iOS application. Now that's a new
混合到你的应用程序中

487
00:26:22,149 --> 00:26:26,051
frontier in iOS, because for however long, 20 years,
这属于开发 iOS 的前沿思想，因为过去 20 年

488
00:26:26,119 --> 00:26:28,120
really, or 30 years, really, if you consider all the way
或者是 30 年，如果把给 iOS 

489
00:26:28,188 --> 00:26:31,723
back to the invention of the technology that led to iOS,
奠基的技术发明都算上的话

490
00:26:31,792 --> 00:26:36,028
people have been programming with basically
人们为了追求面向对象

491
00:26:36,096 --> 00:26:39,831
reference types only, for their object-orienting.
基本上只用了引用类型

492
00:26:39,900 --> 00:26:42,534
But when you do this programming with structs and
但当你用结构体和枚举，特别是协议

493
00:26:42,603 --> 00:26:46,104
enums, and especially when you throw in protocols, (which I
（就是我给你说的那个可重要的，但是

494
00:26:46,173 --> 00:26:47,939
told you I was gonna tell you that are very important, but
现在不能给你讲的那个东西），

495
00:26:48,008 --> 00:26:51,843
I cannot explain to you yet, and generics),
以及泛型编程时

496
00:26:51,912 --> 00:26:54,579
when you start throwing those things all in there, you can
当你开始完全掌握这些东西时

497
00:26:54,648 --> 00:26:58,216
really do a good job of doing real functional programming.
你就真的可以把函数式编程做的很好了

498
00:26:58,285 --> 00:27:02,153
All of the Swift foundation is really designed with a lot
Swift 的基础框架中很多是基于

499
00:27:02,222 --> 00:27:06,057
of functional programming in mind. If you ever really wanna
函数式编程思想设计的。如果你想

500
00:27:06,126 --> 00:27:09,962
kind of see a good example of how to apply this immutability
看更多关于如何实现这种不可变性

501
00:27:10,030 --> 00:27:13,698
and generics, and protocols and all that stuff to build
和在泛型、协议这些基础上搭建

502
00:27:13,767 --> 00:27:16,968
an architecture, chase down all the things that
的体系的例子，就去查看

503
00:27:17,037 --> 00:27:21,006
are going on in the foundation library: string and range and
基础库中的实现方法，String、Range

504
00:27:21,075 --> 00:27:24,075
all these things. Remember, that I said things like
等所有内容。记住我说的类似于

505
00:27:24,144 --> 00:27:26,878
the range is a sequence, or this thing is comparable,
记得我说过 CountableRange 是 Sequence

506
00:27:26,947 --> 00:27:29,414
remember how I said things like that? Okay, well,
或者这个是 Comparable 的之类的吗？

507
00:27:29,483 --> 00:27:32,483
how do you express that? You use protocols,
那如何表达这些概念？你可以使用 Protocol（协议）

508
00:27:32,552 --> 00:27:37,822
with these immutable types, that can be immutable and
和那些不可变的类型

509
00:27:37,891 --> 00:27:41,593
use generics. So I can't explain all that,
以及 Generic（泛型）。我并不能在此一一解释

510
00:27:41,662 --> 00:27:44,362
I've already spent too much time on it than I have to even
因为已经花了太多时间在这些概念上，超过我

511
00:27:44,431 --> 00:27:45,964
talk about it in the lecture today, but just so
应该在今天的课程中讲解的内容，但是

512
00:27:46,033 --> 00:27:49,601
you know, there is a huge advantage of programming in
你们知道的，有时换一种编写代码的方式

513
00:27:49,669 --> 00:27:52,504
a different way; it requires a real mindset change.
会带来巨大的好处。这需要观念上的改变。

514
00:27:52,572 --> 00:27:55,440
So hopefully, you'll take a class where maybe the whole
希望你们有机会写一个类，里面全部内容

515
00:27:55,509 --> 00:27:56,641
class is functional programming,
都基于函数式编程思想

516
00:27:56,710 --> 00:27:58,110
and really you'll get a feel for it.
这样你们就会对这个概念有一定认识了。

517
00:27:58,179 --> 00:28:00,245
Swift does a good job of supporting for
Swift 在基础层面已经对函数式编程

518
00:28:00,313 --> 00:28:04,849
the fundamentals you need to do that. That's kind
提供了你需要的支持。对于应该怎么选择编程思想

519
00:28:04,918 --> 00:28:08,086
of the long-winded answer to which do you choose. If you're
我已经给出了长篇大论式的解答。如果你

520
00:28:08,154 --> 00:28:10,756
doing more of a functional approach, even if you're doing
正在学习更多关于函数式编程的知识，或者只是

521
00:28:10,824 --> 00:28:13,692
a reference-based approach like what you're used to, try
了解传统的基于引用的思想，都可以尝试

522
00:28:13,760 --> 00:28:16,361
to lean towards immutability, try to ask yourself,
向这种不可变的方式上转变。试着问自己

523
00:28:16,430 --> 00:28:21,299
can this thing work and be immutable? Is there some
这些内容不可变后还能正常运作吗？是否有

524
00:28:21,368 --> 00:28:24,169
functionality in my program that I could share by creating
一些功能可以通过泛型来共享其实现部分

525
00:28:24,238 --> 00:28:29,107
a generic, for example. At least those leanings
这种思想上的转变至少

526
00:28:29,176 --> 00:28:31,376
might help you build the apps that are more testable,
会帮助你构建更具有可测试性的应用

527
00:28:31,445 --> 00:28:32,777
because it's a lot easier to write a test for
这会让测试变得更容易

528
00:28:32,846 --> 00:28:34,646
something that's like a mathematical function where
例如一个数学相关的函数

529
00:28:34,715 --> 00:28:36,515
you know the data out is supposed to be the same for
如果可以确认数据在经过处理后

530
00:28:36,584 --> 00:28:38,817
the data in, than it is for something where there's
和传入时保持相同，会比那些

531
00:28:38,886 --> 00:28:40,919
a lot of data that you have to set everything up. Set this,
需要设置很多输入数据的要容易的多。预先设置这个

532
00:28:40,988 --> 00:28:43,688
set this and this and this, and now call the method,
这个以及这个，然后调用方法

533
00:28:43,757 --> 00:28:47,925
that's a lot more difficult to write test cases for, etc.
为这样的方法编写测试用例会非常困难

534
00:28:47,994 --> 00:28:50,428
So that's value and reference. Let's talk a little bit about
以上说的是值和引用。接下来讲一些

535
00:28:50,497 --> 00:28:52,664
the syntax of methods. I'm gonna go fast on this.
方法的语法。我会加快一些速度

536
00:28:52,732 --> 00:28:54,366
Hopefully, you all understand this.
希望你们可以理解这些内容

537
00:28:54,435 --> 00:28:57,168
All parameter names have external names and internal
所有的参数包含外部参数名和内部参数名

538
00:28:57,237 --> 00:29:01,640
names. The internal name is used inside the definition, or
内部参数名用于函数的声明

539
00:29:01,709 --> 00:29:04,276
the inside the implementation of the function.
或函数内容的实现部分

540
00:29:04,345 --> 00:29:06,878
So here I have these two functions, foo and bar. Bar
有两个函数，foo 和 bar。bar 调用了 foo

541
00:29:06,947 --> 00:29:11,416
calls foo. So you can see that inside foo's implementation,
所以在 foo 的内部

542
00:29:11,484 --> 00:29:14,820
it is using the first and the second, whereas bar,
它用了 first 和 second 作为参数名，但是

543
00:29:14,889 --> 00:29:17,923
when bar calls foo, it uses external first and
bar 调用 foo 时， 使用了 externalFirst 和

544
00:29:17,991 --> 00:29:22,694
external second, as the names of the items. And you know
externalSecond 作为参数名

545
00:29:22,763 --> 00:29:25,430
that you can put an under bar to make it so there's no
你可以在没有外部参数名时

546
00:29:25,499 --> 00:29:30,068
external name. We only do that 99.99% of the time with
用下划线来代替。这种下划线的方式我们99.99%的时候只对

547
00:29:30,137 --> 00:29:34,039
the first item. Why do we do it? Because sometimes the name
第一个参数使用。为什么要这样做？因为有时通过函数名

548
00:29:34,107 --> 00:29:38,743
of the method, and/or the type of that first argument, is
或者第一个参数的类型

549
00:29:38,812 --> 00:29:41,780
enough to make it clear what that thing is supposed to be,
已经可以明确的推断出第一个参数应该是什么

550
00:29:41,849 --> 00:29:43,849
so we don't need to put an external name.
这时我们就没必要写外部参数名了

551
00:29:43,917 --> 00:29:45,683
It's kinda clear. All the other parameters,
这样显得更清晰。对于其他参数

552
00:29:45,752 --> 00:29:48,786
we don't have the advantage of having the name of the method
把参数名省略只留函数名没什么好处

553
00:29:48,855 --> 00:29:51,823
there. So that's why we almost never put underbar for
所以几乎不会在除第一个参数名之外的地方

554
00:29:51,892 --> 00:29:56,294
the later ones. By the way, if you only put one
使用下划线。顺带，如果只写了一个

555
00:29:56,363 --> 00:30:00,031
parameter name, then that's both the external name and
参数名，那么这个名称既是外部参数名

556
00:30:00,100 --> 00:30:03,468
the internal name, and that's not that uncommon,
也是内部参数名，这种情况并不罕见

557
00:30:03,537 --> 00:30:07,306
you'll do that occasionally. All right, so you know all
可以偶尔使用。好了，这些就是全部

558
00:30:07,374 --> 00:30:12,344
that. When it comes to doing overriding, subclassing, in
接下来是重写和子类

559
00:30:12,413 --> 00:30:15,747
reference types and classes, when you override, you have to
对于引用类型和对象，可以重写

560
00:30:15,816 --> 00:30:19,584
explicitly let Swift know that you know you're doing that.
你必须明确地让 Swift 知道你要重写

561
00:30:19,653 --> 00:30:21,753
And you do that by putting the override keyword.
要用 override 关键字

562
00:30:21,822 --> 00:30:25,823
So if you override a method from your superclass you have
所以，如果你要重写一个父类的方法

563
00:30:25,892 --> 00:30:29,728
to say override func whatever. You can mark a method or
必须使用 override func。可以将一个方法或

564
00:30:29,797 --> 00:30:33,732
even a whole class final, and that means that it cannot be
整个类标记为 final，这意味着它无法

565
00:30:33,801 --> 00:30:38,269
overridden, subclasses will not be allowed to override it.
被重写，子类不允许重写它

566
00:30:38,338 --> 00:30:42,841
Most languages have that. Now on the topic of methods.
大部分语言拥有这类语法。继续方法这个主题

567
00:30:44,345 --> 00:30:48,447
You've seen, actually you've seen both, but mostly seen and
可以看到，实际上两个都在这里，但是通常你们更熟悉

568
00:30:48,516 --> 00:30:51,984
understood instance methods. These are methods,
实例方法。实例方法

569
00:30:52,052 --> 00:30:56,255
or vars, that are being sent to an instance of the class
或实例变量，可以通过给一个类

570
00:30:56,323 --> 00:31:00,058
struct or enum. In other words, one of them.
结构体或枚举的实例发送消息来访问。也就是给某一个具体对象

571
00:31:00,127 --> 00:31:04,429
Like I create one of them: I create a double of 15.5,
比如我可以创建它们的一个实例：我创建一个值为 15.5 的 Double

572
00:31:04,498 --> 00:31:07,466
I have one, and I can send it messages.
我有了一个实例，就可以给它发送消息

573
00:31:07,534 --> 00:31:11,503
But types, like the type double, the type string,
但是类型，例如 Double，String

574
00:31:11,571 --> 00:31:15,808
the type calculator brain, they can also have methods and
CalculatorBrain，它们也可以拥有方法和

575
00:31:15,876 --> 00:31:21,279
vars. Computed vars, no storage, but computed vars.
变量。计算变量，没有存储空间，是计算得出的变量

576
00:31:21,348 --> 00:31:25,017
All you do to add a method or a var to a type is
要给类型添加方法或变量，只要

577
00:31:25,085 --> 00:31:27,385
you put static in front of the declaration.
将 static 关键字放在声明语句前面即可

578
00:31:27,454 --> 00:31:30,722
So "static func whatever" means this is a function on
static func 意思是这个方法

579
00:31:30,791 --> 00:31:34,726
the type, not on instances of the type, on the type itself.
属于类型。不属于实例，是类型本身的方法

580
00:31:34,795 --> 00:31:37,762
For example, let's think about double here.
还是以 Double 举例

581
00:31:37,831 --> 00:31:43,502
Double actually has quite a few static or type methods and
Double 拥有不少类型方法和

582
00:31:43,571 --> 00:31:47,773
vars. You access them by sending the message to
变量。可以通过发送消息给

583
00:31:47,841 --> 00:31:51,242
Double to the actual word, capital D-O-U-B-L-E. You
Double 来访问。一字不差，D-O-U-B-L-E

584
00:31:51,311 --> 00:31:54,012
don't send it to an instance, you send it to that word. And
不要发送给一个实例，而是发送给那个类型的名称

585
00:31:54,080 --> 00:31:57,715
you've already seen at least one of these, which was pi.
你已经看到过至少一个例子了，比如 π

586
00:31:57,784 --> 00:32:00,753
Remember we said Double.pi and we got the value of pi?
还记得我们通过 Double.pi 取得到了 π 的值吗？

587
00:32:00,821 --> 00:32:05,790
Pi is a var, a computed var, on the class or
π 是一个变量，一个计算变量

588
00:32:05,859 --> 00:32:09,594
struct actually, double, but it also has other methods,
属于 Double 这个结构体。Double 也有一些其他方法

589
00:32:09,663 --> 00:32:12,564
like abs. Abs takes a double value and
例如 abs。abs 接受一个 Double 的值

590
00:32:12,633 --> 00:32:16,701
returns the absolute value of it. That is on the type.
返回这个值的绝对值。这是类型的方法

591
00:32:16,770 --> 00:32:21,039
You say Double.abs, Double.pi. As opposed to, for example,
可以用 Double.abs，Double.pi。但是

592
00:32:21,108 --> 00:32:23,375
if I have a double like x is equal 23.85.
如果我有一个 Double 类型的实例 x，它等于 23.85

593
00:32:23,444 --> 00:32:27,379
So x is now a double. I can't say x Double.pi cause
x 是一个 Double 实例。这时不能通过 x 调用 Double.pi

594
00:32:29,149 --> 00:32:31,950
x is an instance of a double. You see the difference?
因为 x 是 Double 的一个实例。你们是否明白了其中的区别？

595
00:32:32,019 --> 00:32:34,787
We see saying x.pi, trying to send pi
如果我们说 x.pi，尝试把 pi 发送给

596
00:32:34,855 --> 00:32:38,157
to an instance versus sending pi to a type double.
实例，对比发送 pi 给类型 Double 的区别

597
00:32:39,593 --> 00:32:42,460
So what do we use these type methods for?
为什么要用类型方法？

598
00:32:42,529 --> 00:32:45,263
Well, we can't access any instance variables because
我们没法访问任何一个实例变量

599
00:32:45,332 --> 00:32:47,032
we're not sending them to an instance.
因为我们没有给实例发送消息

600
00:32:47,100 --> 00:32:51,035
We mostly use them for utility methods, things like that.
类型方法通常是类中的辅助方法，比如

601
00:32:51,104 --> 00:32:55,640
Constants like pi is a good example. Things that
常量，π 就是一个很好的例子。还有那些

602
00:32:55,709 --> 00:32:59,177
kind of are functions that are associated with this type but
和这个类型本身关联

603
00:32:59,246 --> 00:33:00,846
don't belong to a particular instance or
但不属于任何一个特定的实例

604
00:33:00,914 --> 00:33:03,882
wouldn't really operate on an instance. Now for example,
或者不会真的对一个实例进行操作的方法。例如

605
00:33:03,951 --> 00:33:06,885
you might have an instance method or
可以有一个实例方法

606
00:33:06,954 --> 00:33:10,856
even an instance var called abs, A-B-S, with no arguments,
或一个实例变量叫做 abs，A-B-S，没有参数

607
00:33:10,925 --> 00:33:12,624
That you would send to an instance, and it would take
当你调用它时，它会

608
00:33:12,693 --> 00:33:16,160
the absolute value of the thing you sent it to. But
取这个实例的绝对值

609
00:33:16,229 --> 00:33:19,030
of course the type one has to have an argument because
但是类型方法需要接受一个参数

610
00:33:19,099 --> 00:33:20,265
you're sending it to the type double,
因为你发送消息给 Double 类型

611
00:33:20,334 --> 00:33:21,699
so there's no double involved.
所以并没有 Double

612
00:33:21,768 --> 00:33:25,904
There's no instance of a double involved. Everybody got
没有 Double 实例参与计算

613
00:33:25,972 --> 00:33:30,909
that? Alright: properties. You know all about properties.
所有人都明白了吗？属性，你们都知道什么是属性

614
00:33:30,978 --> 00:33:33,779
We saw computed properties like display value in
我们已经看过了计算属性，比如之前计算器中

615
00:33:33,847 --> 00:33:36,314
our calculator. There's actually some really cool
用来显示的数值。属性有一些非常棒的特性

616
00:33:36,383 --> 00:33:39,717
features on properties. One of the most interesting ones is
其中最有趣的一个是

617
00:33:39,786 --> 00:33:43,155
property observers. What is a property observer?
属性观察器。什么是属性观察器？

618
00:33:43,223 --> 00:33:45,891
A property observer is a little piece of code that
属性观察器是一些代码

619
00:33:45,959 --> 00:33:49,028
will get executed when your property changes.
可以在属性改变的时候自动执行

620
00:33:51,065 --> 00:33:53,498
Anytime your property changes just a little piece of code
任何时候属性改变了，这段代码

621
00:33:53,567 --> 00:33:56,134
can get executed. Now you can actually find out
就会被执行。你能准确地捕捉到

622
00:33:56,203 --> 00:33:58,403
just before your property changes. Or
属性将要改变之前，或者

623
00:33:58,471 --> 00:34:00,438
you can find out just after your property changes.
属性刚刚改变之后

624
00:34:00,507 --> 00:34:03,208
Or both. And the way you do this, and this works for
或者上述两种。这只能应用于

625
00:34:03,276 --> 00:34:06,378
your stored properties, like userIs InTheMiddleOfTyping:
存储属性，比如 userIsInTheMiddleOfTyping

626
00:34:06,447 --> 00:34:08,246
we could put a property observer on there, and
我们可以加一个属性观察器

627
00:34:08,315 --> 00:34:12,183
execute some code every time we change that. It also works
每次它被改变都会执行一段代码。这个功能

628
00:34:12,252 --> 00:34:15,654
for inherited properties, so if you inherit something
也对继承的属性有效，比如继承了某些

629
00:34:15,723 --> 00:34:19,691
from your superclass, you can put these properties in and
父类的属性，可以通过属性观察器

630
00:34:19,760 --> 00:34:24,730
notice that it changed. By the way, if you have a property
观察它们的改变。顺便，如果属性

631
00:34:24,798 --> 00:34:28,934
which is a value type, (a struct or
是值类型，如结构体

632
00:34:29,003 --> 00:34:31,769
something, like an array or an dictionary), this property
数组、字典等，这些属性观察器

633
00:34:31,838 --> 00:34:34,639
observer stuff will happen if that thing gets changed,
会在它们指向的值被改变时

634
00:34:34,708 --> 00:34:37,709
if it gets mutated. So if you add something to the array,
或是包含的内容被改变时触发。比如向数组中添加元素

635
00:34:37,777 --> 00:34:40,112
boom, the Property Observer will kick in and say,
那就炸了，属性观察器会触发并告诉你

636
00:34:40,181 --> 00:34:43,081
"that changed". How do these Property Observers
“有东西改变了”。属性观察器是

637
00:34:43,149 --> 00:34:46,318
work? They look a lot like a computed property. Remember
基于什么原理工作的呢？它们很像计算属性那样。还记得

638
00:34:46,386 --> 00:34:48,286
that the computed property displayValue had get and
displayValue 的 get 方法执行时

639
00:34:48,355 --> 00:34:50,656
then we had some code, And then we had set and
我们在 get 中加入了一些别的代码，set 的时候

640
00:34:50,724 --> 00:34:53,057
we had some code? This is similar except for
也是一样。这基本上是类似的，除了

641
00:34:53,126 --> 00:34:57,329
get and set it's will set, or did set.
这个是 willSet 和 didSet

642
00:34:59,566 --> 00:35:01,332
By the way, you probably would never (I don't even know if
顺便，你可能永远不会（我也不知道

643
00:35:01,401 --> 00:35:04,236
you can) use this in a computed property because
是不是能这么做）将属性观察器用于计算属性，因为

644
00:35:04,304 --> 00:35:06,004
you've got the set clause there so
既然已经有了 set 语句

645
00:35:06,073 --> 00:35:07,339
you can just put it right in set.
完全可以将代码放在 set 里

646
00:35:07,407 --> 00:35:10,409
You don't need to find out when it's set because you set
根本不需要去监视何时它被改变，因为只有你的 set 方法在改变它

647
00:35:10,477 --> 00:35:13,311
it. But for stored properties and inherited properties,
但是存储属性和继承来的属性不一样

648
00:35:13,380 --> 00:35:15,880
that make sense, so you have willSet.
这时属性观察器有存在价值，所以有了 willSet

649
00:35:15,949 --> 00:35:18,683
Now, willSet, first of all, you put it all in a curly
现在，willSet，首先你要把大括号

650
00:35:18,752 --> 00:35:21,853
brace after the property just like if you were doing
放在属性的后面，像计算属性一样

651
00:35:21,922 --> 00:35:23,922
a computed property but, this is not a computed property,
但是这不是计算属性

652
00:35:23,991 --> 00:35:25,757
just adding a curly brace doesn't make it a computed
加上大括号不会让它变成计算属性

653
00:35:25,826 --> 00:35:29,494
property, you have to put get or set in there, but,
你要里面加上 get 或 set，但是

654
00:35:29,563 --> 00:35:33,031
if I put willSet, then, inside that code,
如果在里面加上了 willSet

655
00:35:33,100 --> 00:35:35,534
there's a special variable just like there in the set
会出现一个特殊的变量，和 set 计算属性时

656
00:35:35,603 --> 00:35:38,270
case of computer property, called newValue, and
的情况类似，叫做 newValue

657
00:35:38,338 --> 00:35:42,073
that is the value that that thing is going to be set to.
这个值将会被赋予给这个属性

658
00:35:42,142 --> 00:35:44,309
It's not set yet. Some property,
但是还没赋予给它。一些属性

659
00:35:44,378 --> 00:35:46,811
see some stored property up there? It has not yet
看到上面那些存储属性了吗？它还没

660
00:35:46,880 --> 00:35:49,914
been set to newValue but it's going to be. And then didSet,
被设置成 newValue，但马上就要设置了

661
00:35:49,983 --> 00:35:52,917
that code occurs after some property has been set and
didSet 中的那些代码在属性被设置之后执行

662
00:35:52,986 --> 00:35:55,720
the special variable in there is oldValue.
在那里特殊变量叫做 oldValue

663
00:35:55,789 --> 00:35:58,456
That's the value it used to have before it got set. So
这个值是它被改变前的值

664
00:35:58,525 --> 00:36:01,159
you can compare if they've changed, for
你可以对比是否发生了变化

665
00:36:01,228 --> 00:36:05,864
example. So where do we use these things?
这些特性要用在哪里呢？

666
00:36:05,932 --> 00:36:08,734
Probably the number one place that we use them is in our
可能最重要的一个用途是在

667
00:36:08,803 --> 00:36:14,205
Controller in view. Let's say I'm a button and
控制视图中。比如，我是个按钮

668
00:36:14,274 --> 00:36:16,941
my background color changes. I inherit my background color
我的背景色改变了，我的背景色是继承自

669
00:36:17,010 --> 00:36:21,413
from my super class, UI view. Up the chain of super classes.
继承树最上层的父类 UIView 的

670
00:36:21,482 --> 00:36:22,847
Every time the background color changes,
每次背景色改变时

671
00:36:22,916 --> 00:36:25,116
the button wants to redraw itself so
这个按钮都想重绘自己

672
00:36:25,185 --> 00:36:29,688
it will have var background color is a UI color,
所以它有一个背景色属性，类型是 UIColor

673
00:36:29,757 --> 00:36:32,791
open curly brace, didSet open curly brace
添加一个大括号，didSet 再跟一个大括号

674
00:36:32,860 --> 00:36:38,630
draw myself closed curly brace. Question? Okay,
在这里重绘自身。有什么问题？

675
00:36:38,699 --> 00:36:41,599
so the question is, if someone changes some stored property
问题是，如果某人改变了存储属性

676
00:36:41,668 --> 00:36:44,502
there, am I responsible for doing something about that
我是否要负责在

677
00:36:44,571 --> 00:36:46,572
in willSet or didSet? Do I have to actually set it? And
willSet 或 didSet 中做些什么？我是否真的要去设置它？

678
00:36:46,640 --> 00:36:48,807
the answer is no. Okay, that's being set somewhere else.
答案是否。如果被别的什么地方改变了

679
00:36:48,875 --> 00:36:50,675
You're just getting a chance to run some other code that
你只是获得了一个机会去执行其他代码

680
00:36:50,744 --> 00:36:53,145
you wanna run just before and just after it happens.
你希望执行的是 set 前后的事情

681
00:36:53,213 --> 00:36:55,547
But you're not responsible for setting the actual value.
你无需负责 set 这件事本身

682
00:36:55,616 --> 00:36:57,716
That's done for you. That's why you get to
系统已经为你做好了，所以你得到是

683
00:36:57,784 --> 00:37:02,420
see the old value and the new value in the two of them.
oldValue 和 newValue

684
00:37:02,489 --> 00:37:05,323
So we'll see this next week when we start drawing on
我们下周讲屏幕绘图之后会涉及这些

685
00:37:05,392 --> 00:37:08,126
screen, where we're gonna be watching properties change so
那时我们会去观察属性改变

686
00:37:08,194 --> 00:37:14,166
we can cause ourselves to redraw. Next, lazy properties.
来决定什么时候去调用自身的重绘。接下来，lazy（延时）属性

687
00:37:14,235 --> 00:37:19,938
Lazy initialization is a really powerful tool.
延时初始化是一个强大的工具

688
00:37:20,006 --> 00:37:23,975
It's gonna get you out of a lot of binds in this class.
这可以帮你减少很多的麻烦

689
00:37:24,044 --> 00:37:27,679
What does it mean? A lazy var, a var
具体是什么意思？一个延时变量，是一个变量

690
00:37:27,748 --> 00:37:32,884
that you say lazy in front of, whatever it's set equal to,
在前面加上 lazy 关键字，不管它被赋什么值

691
00:37:32,953 --> 00:37:36,688
that equals doesn't actually happen until someone accesses
都不会真的立刻执行，直到某处访问了这个值

692
00:37:36,757 --> 00:37:41,593
that var. Until someone asks for the value of that var,
直到某处需要这个变量的值之前

693
00:37:41,662 --> 00:37:45,030
it doesn't actually do the initialization there.
它都不会真的初始化

694
00:37:45,098 --> 00:37:46,698
It doesn't do that equal something.
这和常规的赋值不一样

695
00:37:46,767 --> 00:37:48,199
So it's lazy. It's waiting.
所以它是延时的。它会等待

696
00:37:48,268 --> 00:37:51,136
Now why do you wanna be lazy? Well, one obvious reason
为什么需要 lazy 呢？一个明显的原因

697
00:37:51,205 --> 00:37:53,772
is like here, lazy var brain equals calculator
像这样，lazy var brain = CalculatorBrain()

698
00:37:53,840 --> 00:37:56,307
brain, what if calculator brain was really expensive to
如果 CalculatorBrain 的创建非常耗资源

699
00:37:56,376 --> 00:37:58,843
create. What if it opened a network connection because
或者它会打开一个网络连接

700
00:37:58,912 --> 00:38:01,379
we're going to share the calculation with the internet
我们会把计算结果共享至互联网

701
00:38:01,448 --> 00:38:02,413
or something, you know what I mean,
或者一些其他情况，你应该知道我的意思了

702
00:38:02,482 --> 00:38:04,149
do something that is expensive.
总之就是做一些耗资源的操作

703
00:38:04,218 --> 00:38:05,083
Well, you wouldn't want to do it,
好吧，你肯定不想这样做

704
00:38:05,151 --> 00:38:08,253
unless someone actually tried to access the brain,
除非某处真的需要访问这个 brain

705
00:38:08,321 --> 00:38:10,922
called set up operand on it or something. Then you would
调用设置操作数或者其他什么。这时你才

706
00:38:10,991 --> 00:38:12,424
want to actually do the work to create it.
想要真的创建它

707
00:38:12,493 --> 00:38:14,493
Okay so one reason to be lazy,
这是一个需要 lazy 的理由

708
00:38:14,562 --> 00:38:17,128
it's not that important of a reason it turns out, but
延后高消耗的操作这点

709
00:38:17,197 --> 00:38:21,500
one is to delay expensive operations. But
似乎并没有那么重要

710
00:38:21,569 --> 00:38:25,236
what's another reason to do it? Well, in Swift,
但是另一个原因是，在 Swift 中

711
00:38:25,305 --> 00:38:30,275
all vars have to be initialized. Remember that?
所有的变量都要被初始化，还记得吗？

712
00:38:30,343 --> 00:38:32,143
Remember we added userIsInTheMiddleOfTyping.
我们曾添加了 userIsInTheMiddleOfTyping

713
00:38:32,212 --> 00:38:34,579
And we didn't say, equals false. And we got an error.
我们没有让它等于 false，这时产生了一个错误

714
00:38:34,648 --> 00:38:38,116
It said we had no init, because we hadn't initialized
说缺少构造器，因为我们没有初始化它

715
00:38:38,184 --> 00:38:42,921
that. Not only did they all have to be initialized, but
不仅所有变量都要初始化，而且

716
00:38:42,989 --> 00:38:45,457
they all had to be initialized before you could even send
属性要在可以被发送消息前初始化

717
00:38:45,525 --> 00:38:50,095
a message to that class, even internally. So
即使在类内部也是如此

718
00:38:50,163 --> 00:38:52,697
you can't invoke any of your own methods until you fully
也就是你无法调用任何一个实例方法，直到

719
00:38:52,766 --> 00:38:55,834
initialize yourself. What if one of the things you want to
实例完全初始化了。如果你希望某个属性

720
00:38:55,902 --> 00:39:02,040
initialize needs to call a method on yourself? It's
的初始化过程调用另一个实例方法怎么办？

721
00:39:02,109 --> 00:39:05,243
impossible. Because if you need to initialize something
这是不可能的。比如你需要初始化某个属性

722
00:39:05,312 --> 00:39:07,045
to be allowed to send messages to yourself and you need
才能来给实例发消息

723
00:39:07,114 --> 00:39:09,047
to send a message to yourself to initialize something,
但这个属性的初始化，又要求实例已经完成了构造

724
00:39:09,116 --> 00:39:12,751
it's a deadlock. You can't do it. Okay, well lazy let's you
这就陷入了僵局。原本没法这么做，但是可以通过 lazy 实现

725
00:39:12,820 --> 00:39:16,221
do it. Because you can say for example, the last one there;
比如用这里最后的 myProperty 举例

726
00:39:16,290 --> 00:39:20,925
lazy my property equals some method on myself. This is not
将这个延时属性设置为实例的某个方法的值

727
00:39:20,994 --> 00:39:24,896
going to be executed until someone says my property and
直到某人访问它之前，这段代码都不会运行

728
00:39:24,965 --> 00:39:27,733
no one's allowed to access my property until I'm fully
记住，直到实例初始化完成之前，谁也不能访问这个属性

729
00:39:27,801 --> 00:39:32,437
initialized. So by definition there's no way
所以很明确

730
00:39:32,506 --> 00:39:35,440
that that is gonna try to get initialized until I'm already
在实例完全初始化之前，延迟属性一定没有初始化

731
00:39:35,508 --> 00:39:40,011
fully initialized. And yet this lazy thing counts as this
但这时延时属性会被视作

732
00:39:40,080 --> 00:39:46,284
thing having been initialized. So this is the big loophole.
已经初始化了。这是一个很大的“漏洞”

733
00:39:46,353 --> 00:39:49,554
Lazy var myProperty counts as having been initialized
延时属性被视为已初始化

734
00:39:49,623 --> 00:39:51,389
even though it really hasn't yet. Because it's waiting for
但实际上它没被初始化，因为 myProperty 在等待

735
00:39:51,458 --> 00:39:55,393
something to actually access myProperty. But it counts for
某处实际访问它。所以这个漏洞的存在

736
00:39:55,462 --> 00:39:58,263
the purposes of that rule, so now someone comes along later
是为了遵守那条规则。现在某处实际访问了它

737
00:39:58,332 --> 00:40:00,331
and accesses it, now we can call this method. So
我们再调用这个方法

738
00:40:00,400 --> 00:40:03,101
do you see how deferring the calling of this method in
你们理解了吗？推迟调用这个方法

739
00:40:03,169 --> 00:40:05,804
order to initialize this gets us around that requirement
使得我们可以摆脱

740
00:40:05,873 --> 00:40:08,173
that everything be initialized?
所有内容都要被初始化的限制

741
00:40:08,241 --> 00:40:10,309
It's really tricky. And then the middle one there,
这真的有点复杂。中间这个

742
00:40:10,377 --> 00:40:13,979
someProperty, that's super tricky. Because you can
someProperty，它更复杂。你可以

743
00:40:14,048 --> 00:40:17,216
actually have a closure, (remember what a closure is,
用一个 closure（闭包），（回忆下什么是闭包

744
00:40:17,284 --> 00:40:19,284
right from calculator brain, it's just a function,
在 CalculatorBrain 中用到过，其实闭包就是函数

745
00:40:19,352 --> 00:40:22,488
in line function), you can actually have a closure
一个内联函数），你可以用一个闭包

746
00:40:22,556 --> 00:40:26,090
to initialize your thing lazily. All you do is you
来延时初始化一个变量。你要做的仅仅是

747
00:40:26,159 --> 00:40:28,493
put the closure, open curly brace, close curly brace.
把闭包写在这里，开始大括号，结束大括号

748
00:40:28,562 --> 00:40:31,796
It obviously has to return something of the type
显然，还要返回符合这个变量类型的结果

749
00:40:31,865 --> 00:40:35,233
of that var. And then just put the little open parenthesis,
然后还要加上一对小括号

750
00:40:35,302 --> 00:40:38,237
close parenthesis at the end. When we open parenthesis and
在闭包的结尾

751
00:40:38,305 --> 00:40:39,438
close parenthesis at the end of the closure,
在闭包的结尾加上小括号

752
00:40:39,507 --> 00:40:42,674
that means execute this closure right now. But
意味着立刻执行这个闭包

753
00:40:42,742 --> 00:40:45,611
it's not gonna execute right now, it's gonna act lazy so
但是实际上它并不会立刻执行，因为它是延时执行的

754
00:40:45,679 --> 00:40:50,381
it's gonna happen later. And that means that that closure
它会稍后才被执行。这意味着

755
00:40:50,450 --> 00:40:53,919
inside could reference self. Because self will be fully
闭包内部可以引用 self。因为当这个闭包执行的时候

756
00:40:53,988 --> 00:40:56,154
initialized by the time this closure gets executed,
self 肯定已经被完全初始化了

757
00:40:56,223 --> 00:41:00,058
since it's lazily executed. So
前提是确保它是延时执行的

758
00:41:00,127 --> 00:41:02,694
lazy will get you out of some of these tricky wickets,
lazy 可以使你摆脱这类棘手的处境

759
00:41:02,762 --> 00:41:04,963
because when you see me talk about initialization,
当你们听我讲到初始化时

760
00:41:05,032 --> 00:41:08,333
you're gonna be like, "I don't want to do that, ever".
你们可能会说“我永远不想那样做”

761
00:41:08,402 --> 00:41:09,701
You're going to try and avoid it, and
你们会尝试避免它

762
00:41:09,770 --> 00:41:12,704
this is a good way to avoid it. So yeah,
这就是一种很好的避免的方式

763
00:41:12,773 --> 00:41:18,810
it still satisfies all those things. Alright, on to Array.
它仍然满足所有规则。好了，下面讲 Array（数组）

764
00:41:18,879 --> 00:41:21,079
Everybody knows what an array is. Everyone knows what
所有人都知道数组是什么，所有人都知道泛型数组是什么

765
00:41:21,148 --> 00:41:23,549
a generic array is. You just, when you declare the array,
你肯定知道，因为当你声明一个数组时

766
00:41:23,617 --> 00:41:25,517
you have to say what type of things are gonna
必须指明它的内容的类型是什么

767
00:41:25,585 --> 00:41:28,553
be in the array. There's a different syntax though,
也有另一种语法

768
00:41:28,622 --> 00:41:32,724
which I didn't introduce when I did dictionary in the demo.
之前的 demo 中，我用了字典，但是没有提到过这个语法

769
00:41:32,793 --> 00:41:36,428
But you can declare an array, those two yellow things
你可以声明一个数组，上面黄色标注的两个声明方法

770
00:41:36,497 --> 00:41:38,696
up there are exactly the same thing. So,
是一样的

771
00:41:38,765 --> 00:41:39,464
open square bracket,
左半方括号

772
00:41:39,533 --> 00:41:41,934
string close square bracket is exactly the same as saying
String，右半方括号

773
00:41:42,002 --> 00:41:45,537
array angle bracket string. It's just kind of a special
这与 Array 加上一对尖括号，括起来 String，是等价的

774
00:41:45,606 --> 00:41:48,873
way to declare an array and it actually seems to be
[String] 这种声明数组的特殊方式更被大众接受

775
00:41:48,942 --> 00:41:51,443
the preferred way. I actually prefer the other way because
但是我比较喜欢用 Array<String>

776
00:41:51,512 --> 00:41:54,079
it's a little clearer to you that are learning that this is
更明确地告诉你们这些学生，这是个数组

777
00:41:54,148 --> 00:41:57,182
an array, because it says the word array and string.
毕竟包含了 Array 和 String 两个单词

778
00:41:57,251 --> 00:41:59,918
But open square bracket, close square bracket,
不过中括号的方式

779
00:41:59,986 --> 00:42:02,187
we know that's going to be index into an array so
我们知道这是通过索引访问数组元素的方式

780
00:42:02,256 --> 00:42:03,722
it looks kind of array-ish but
它也看起来更有数组的风格

781
00:42:03,790 --> 00:42:08,594
just get used to it. [String] means an array of string.
习惯了就好了。[String] 代表一个包含字符串的数组

782
00:42:08,662 --> 00:42:11,997
That's the name of that type
这是字符串数组这个类型的名称

783
00:42:12,066 --> 00:42:16,635
array of string. So if I had a string right here like
如果我有一些字符串

784
00:42:16,704 --> 00:42:21,106
this giraffe, cow, doggie, and bird. Four animals in here,
比如 Giraffe，Cow，Doggie，Bird 这四种动物

785
00:42:21,175 --> 00:42:24,475
four strings and I said animals dot append ostrich,
四个字符串，然后我调用 animals.append("Ostrich")

786
00:42:24,544 --> 00:42:28,147
well append appends something onto the array, now the thing
append 这个方法会将一些东西加入到数组中，

787
00:42:28,215 --> 00:42:30,616
you are appending has to be the same type obviously
你加入的新东西显然也必须

788
00:42:30,684 --> 00:42:33,218
as the type of everything in the array, however the type
和数组中其他元素是同一个类型

789
00:42:33,286 --> 00:42:36,955
was declared. Notice that animals is in inferred.
因为类型已经被声明了。注意这里 animals 的类型已经

790
00:42:37,024 --> 00:42:40,225
By Swift, to be an array of string. Because Swift sees
被 Swift 推断为 Array<String>，因为 Swift

791
00:42:40,294 --> 00:42:42,126
that you sent it to an array of things and
通过检查你在数组中包含的每一个元素

792
00:42:42,195 --> 00:42:44,096
it looked at all the things and they were all strings.
判断出它们全都是字符串

793
00:42:44,164 --> 00:42:46,965
So it said, the animals must be an array of string. Now,
所以它断定，animals 必然是一个 Array<String>

794
00:42:47,033 --> 00:42:50,335
this line of code animals.append("Ostrich").
这行代码 animals.append("Ostrich")

795
00:42:50,403 --> 00:42:51,036
That's very bad.
存在问题

796
00:42:51,104 --> 00:42:53,004
Can anyone tell me why that's not gonna work?
谁能告诉我它为什么有问题？

797
00:42:53,073 --> 00:43:02,247
Yeah? >> That's exactly right.
>> 答得好，给你颗糖吃

798
00:43:02,316 --> 00:43:06,485
We define this animal's variable with let, so
我们声明 animals 时用的是 let

799
00:43:06,554 --> 00:43:09,888
it's immutable. So when we say append an ostrich onto
它是不可变的，所以我们 append("Ostrich")

800
00:43:09,956 --> 00:43:13,025
an immutable thing, it's going to crash my program.
添加进这个不可变的数组，就会导致程序崩溃

801
00:43:13,093 --> 00:43:15,027
But actually, it won't even crash my program.
其实不会真的导致程序崩溃

802
00:43:15,095 --> 00:43:15,727
It won't even compile.
而是连编译都无法通过

803
00:43:15,796 --> 00:43:17,796
Like, Swift compiler's just gonna say, no way,
Swift 编译器会告诉你，这样做不行

804
00:43:17,865 --> 00:43:19,865
you can't do append of something or other.
你没法 append 或者做其他操作

805
00:43:19,934 --> 00:43:22,467
So that's a good one over there, you got that.
这就是个很好的例子，你们已经掌握了

806
00:43:22,536 --> 00:43:24,336
How about this one? I'll give you a second chance for
那么这个呢？再给你们一次机会

807
00:43:24,405 --> 00:43:27,139
everyone. Why is this one no good? Okay,
下面这个有什么错误？

808
00:43:27,208 --> 00:43:31,477
I'm trying to get animals[4] over there, why? Nobody?
我尝试获取 animals[4]，为什么，谁要回答？

809
00:43:31,545 --> 00:43:38,717
This one's easier. Array index, yes! Array index is
这个问题比较简单。数组的索引，答得好，再发颗糖

810
00:43:38,786 --> 00:43:42,553
out of bounds because arrays are indexed starting at zero.
数组的索引值越界了，数组是从 0 开始索引的

811
00:43:42,622 --> 00:43:45,357
Okay, so giraffe, cow, doggie, bird that's zero, one, two and
所以 Giraffe，Cow，Doggie，Bird 对应 0，1，2，3

812
00:43:45,425 --> 00:43:48,727
three. So if I say, give me array number four, bam,
如果我说，把第四个给我

813
00:43:48,795 --> 00:43:53,165
crashed my program array index out of bounds.
程序就会因为数组索引越界而崩溃

814
00:43:53,234 --> 00:43:57,669
Let's talk about the fact that array is a sequence.
下面讲讲数组作为一个 Sequence（序列）的特性

815
00:43:57,738 --> 00:44:00,872
Array is actually a collection and collections are sequences.
数组实际上是一个 Collection（集合），而集合又是序列

816
00:44:00,941 --> 00:44:05,577
And a sequence means I can do for in on it. So if I say for
一个序列意味着我可以对它进行 for...in 循环

817
00:44:05,646 --> 00:44:09,348
animal in animals, my little for loop will get executed
如果我说 for animal in animals，这个 for 循环就会执行四次

818
00:44:09,416 --> 00:44:12,651
four times, once with animal being giraffe, next one with
第一次 animal 取值为 Giraffe，第二次

819
00:44:12,720 --> 00:44:14,586
animal being cow, next one with animal being doggie,
animal 是 Cow，接下来是 Doggie

820
00:44:14,655 --> 00:44:19,791
next one animal being bird. Okay, so that's a really cool
最后一个是 Bird。这真是一个很棒的功能

821
00:44:19,860 --> 00:44:23,562
feature. Remember this is the only for there is in swift.
记住这是 Swift 中唯一的 for 循环形式

822
00:44:23,631 --> 00:44:31,069
For in, that's the only for there is, nothing else.
for...in 这就是唯一的，没有其他了

823
00:44:31,138 --> 00:44:36,107
So array in a lot of classes and structs
在数组，以及 iOS 众多类和结构体中

824
00:44:36,176 --> 00:44:38,376
in iOS have some interesting methods
有一些有趣的方法

825
00:44:38,445 --> 00:44:43,648
that have arguments that are closures. So I teach closures
它们有闭包类型的参数

826
00:44:43,717 --> 00:44:45,851
to you right at the beginning of the of the quarter.
所以我在这期课程的开头就先讲了闭包

827
00:44:45,919 --> 00:44:48,520
And why do I do that? Because closures are an important
为什么我要先讲它，因为如果你想把 iOS API 用好

828
00:44:48,589 --> 00:44:51,456
thing to understand if you want to really use iOS API
就应该先理解闭包这个重要的概念

829
00:44:51,525 --> 00:44:55,794
well. So let's take at this (just so we can learn a little
我们看看这个（我们从中还可以学到

830
00:44:55,863 --> 00:44:58,497
bit about how closures can make our API great,
如何把我们自己的 API 设计的更好

831
00:44:58,565 --> 00:45:02,166
especially again if you're doing functional programming,
尤其是你要用函数式编程的话

832
00:45:02,235 --> 00:45:05,904
closures can be really good), but why are closures so great?
闭包可以从中起到很大作用），闭包为什么这么有用？

833
00:45:05,972 --> 00:45:08,907
So let's look at this so, this first function right here
我们看看这些，第一个方法

834
00:45:08,976 --> 00:45:11,776
called filter is an array method.
叫做 filter，是数组的方法

835
00:45:11,845 --> 00:45:16,515
Nothing special about it, it's just func in array.
它没什么特别的，只是一个数组的方法

836
00:45:16,584 --> 00:45:20,853
It has one argument, which is called includeElement.
它有一个参数，叫做 includeElement

837
00:45:22,590 --> 00:45:26,824
And that argument is a function. It's a function that
这个参数是一个函数

838
00:45:26,893 --> 00:45:29,827
takes one argument which is of the same type of the things in
这个函数有一个类型与数组元素类型一致的参数

839
00:45:29,896 --> 00:45:33,999
the arrays, cuz it's a t. So I have an array angle bracket t.
因为这个类型是 T，所以我有一个 Array<T>

840
00:45:34,067 --> 00:45:37,535
It's a generic type so this function is declared in that
这是一个泛型，这个函数是

841
00:45:37,604 --> 00:45:40,205
generic type so the t means the same t, the same type. So
基于这个泛型声明的。所以这个 T 是同一个 T，同一个类型

842
00:45:40,274 --> 00:45:43,141
if I have an array of strings this filter expects this
如果我有一个字符串数组，那么 filter 方法的参数

843
00:45:43,210 --> 00:45:46,044
to be a function that takes a string. As its only argument.
就是一个接受字符串作为唯一参数的函数

844
00:45:46,113 --> 00:45:48,280
And it returns a Bool, so that's the argument.
并且这个函数返回一个布尔值

845
00:45:48,348 --> 00:45:50,549
The argument is a function that takes a string and
所以 filter 的参数是一个函数，接受字符串

846
00:45:50,617 --> 00:45:53,184
returns a Bool or takes a T, whatever that is, and
也就是对应的 T 类型，并返回布尔值

847
00:45:53,253 --> 00:45:56,388
returns a Bool. And then what's the return
那么 filter 方法本身

848
00:45:56,457 --> 00:46:00,425
value of this filter thing? It's an array of T, so another
返回什么东西？返回的是 T 类型元素的数组

849
00:46:00,494 --> 00:46:03,629
array with the same kind of elements. So what does filter
是一个与原数组包含同类型元素的新数组

850
00:46:03,697 --> 00:46:07,499
do? Filter takes every single element In the array that
filter 有什么用？filter 对数组中的每个元素

851
00:46:07,568 --> 00:46:10,435
you're sending it to and it runs that little function. And
执行一次传入的函数

852
00:46:10,504 --> 00:46:13,238
if that function returns true, it includes it in the array it
如果函数返回 true，就把那个元素包含在返回的数组中

853
00:46:13,307 --> 00:46:15,940
returns. If it returns false it doesn't.
如果函数返回 false

854
00:46:16,009 --> 00:46:17,408
It throws it out. So
就把那个元素过滤掉（不放入返回数组）

855
00:46:17,477 --> 00:46:21,346
it's a filter: it's filtering your array and creating a new
filter 就是过滤器：它创建一个新数组来过滤原数组

856
00:46:21,415 --> 00:46:24,916
array with all the things you don't want as defined by this
根据作为参数传入的函数来判断

857
00:46:24,985 --> 00:46:26,885
function that you're providing as an argument.
哪些是你不想要的元素

858
00:46:26,954 --> 00:46:29,020
With all the things you don't want thrown out. So for
把你不想要的元素都过滤掉

859
00:46:29,089 --> 00:46:33,559
example here, I have this var that I'm creating,
例如：我有一个变量

860
00:46:33,627 --> 00:46:37,028
bigNumbers, and I'm creating an array on the fly 2,
叫做 bigNumbers，我紧接着创建了一个数组 [2,47,118,5,9]

861
00:46:37,097 --> 00:46:39,798
47,118,5,9, (see? I created an array), and look,
（看，我创建了一个数组）

862
00:46:39,867 --> 00:46:44,469
I'm sending it a message right away. Yeah, I didn't have to
我紧接着给数组发送了一个消息

863
00:46:44,538 --> 00:46:47,939
put it into another var, by the way, I could have but,
我没必要声明另一个变量，尽管我可以那样做

864
00:46:48,008 --> 00:46:51,509
I just want all be on one line here. I created this array and
但是在这里我更希望只用一行代码。我创建了这个数组

865
00:46:51,578 --> 00:46:53,445
I'm sending it the message filter and
然后给它发送消息 filter

866
00:46:53,514 --> 00:46:55,714
look what I'm providing for the argument there.
仔细看参数这里我写的是什么

867
00:46:57,284 --> 00:46:59,618
That include element it has an underbar, so, you don't have
因为 includeElement 的外部参数名有下划线，所以没必要

868
00:46:59,686 --> 00:47:03,488
to actually put the include element column in there. So,
真的写上 includeElement 这个参数名

869
00:47:03,557 --> 00:47:07,525
what am I putting in there? That's a closure. So
所以我在这里填入的是什么？是一个闭包

870
00:47:07,594 --> 00:47:11,496
that means, it's a function. Now, Swift knows that this is
这意味着，它是个函数。Swift 知道它

871
00:47:11,564 --> 00:47:13,031
a function that returns a bool. So
是个函数，而且会返回布尔值

872
00:47:13,100 --> 00:47:16,868
I don't have to put the word return in there. I can use
所以我没必要在闭包里加上 return

873
00:47:16,937 --> 00:47:20,639
dollar zero to be the one and only argument to the function.
我可以用 $0 代表闭包的第一个也是唯一的一个参数

874
00:47:20,708 --> 00:47:22,207
And I'm just going to check and
我接下来要检查

875
00:47:22,276 --> 00:47:23,875
see if dollar zero is greater than 20, in other words,
$0 是否比 20 大，也就是说

876
00:47:23,944 --> 00:47:28,947
is this a big number. So I get back an array which has only
检查它是不是个“大数字”。然后我取得了一个新数组

877
00:47:29,016 --> 00:47:32,951
47 and 118 in it, because I've filtered out all the things
里面只有 47 和 118，因为我已经把所有

878
00:47:33,020 --> 00:47:38,156
where the value's not greater than 20. Imagine writing
不满足大于 20 这个条件的数都过滤掉了。想象一下

879
00:47:38,225 --> 00:47:43,194
this line of code without filter. You're gonna have
如果不依靠 filter 来实现这行代码

880
00:47:43,263 --> 00:47:45,630
to a for loop. You're gonna have to create another array.
你可能要写个 for 循环，然后创建一个新数组

881
00:47:45,699 --> 00:47:48,133
You're gonna have to run this little function,
然后执行这个小函数

882
00:47:48,202 --> 00:47:50,169
call this function, create a new array and
调用这个函数，创建新数组

883
00:47:50,237 --> 00:47:52,170
add, append thing to do it. It's at least four or
然后把符合条件的加进去

884
00:47:52,239 --> 00:47:55,807
five lines of code. And here you get it in one line of
至少也要四五行代码。用了 filter，只用一行代码就实现了

885
00:47:55,876 --> 00:47:59,311
code, okay? So you see how closure there has helped us.
闭包是如何帮我们实现这个功能的？你们理解了吗

886
00:47:59,380 --> 00:48:02,481
This is also much more readable cuz you can read this
这也让代码更具可读性

887
00:48:02,550 --> 00:48:05,718
like this: Let the big numbers equal this array, but
可以这样读：让 bigNumbers 等于这个数组

888
00:48:05,786 --> 00:48:08,053
filter for things there are greater than 20.
但是只要其中比 20 大的

889
00:48:09,223 --> 00:48:11,356
That reads nicely, so I'm just clear.
这样读起来太顺了，表达清晰

890
00:48:11,424 --> 00:48:14,426
It's very easy to understand what's going on here.
非常容易让人理解这行代码在做什么

891
00:48:14,495 --> 00:48:19,030
So here's another one. It's called map. What does map do?
另一个方法，叫做 map，它是做什么的？

892
00:48:19,099 --> 00:48:21,967
It takes a closure, or a function. And
它也接受一个闭包，或者说一个函数

893
00:48:22,036 --> 00:48:26,371
it executes that function in order to transform each
它会执行那个函数

894
00:48:26,439 --> 00:48:29,107
of the elements in the array you're sending map to,
将你传入数组的每个元素进行转化

895
00:48:29,175 --> 00:48:30,342
to a new array.
然后输出到一个新数组

896
00:48:30,411 --> 00:48:32,878
Now that transformation could be anything that a function
这种转化可以是任何形式的，只要通过函数能做到

897
00:48:32,946 --> 00:48:36,048
can do. And you can convert it to any new type you want.
甚至可以转化为任何你想要的新类型

898
00:48:36,116 --> 00:48:39,083
Although it's one function, so it
但是它是一个函数

899
00:48:39,152 --> 00:48:42,253
coverts everything to the same type. So you could use it for
它只能把所有东西转化为同一个类型

900
00:48:42,322 --> 00:48:44,790
type conversions like I have here. I've taken 1,
你可以用它来实现类型转化。例如这里

901
00:48:44,858 --> 00:48:48,059
2, 3 and mapped it to the string versions of 1, 2, 3, so
我把数字 1，2，3 映射成字符串形式的 "1"，"2"，"3"

902
00:48:48,128 --> 00:48:51,429
now I have the new array with strings in it. String of 1,
现在我得到了一个新数组，包含字符串的数组 ["1"，"2"，"3"]

903
00:48:51,498 --> 00:48:54,466
string of 2, string of 3. That's a trivial mapping.
这只是个意义不大的映射

904
00:48:54,535 --> 00:48:56,801
But you can imagine much more powerful mappings where you
但你可以想象下功能更加强大的映射

905
00:48:56,870 --> 00:48:58,036
take each element of the array, and
对数组的每个元素

906
00:48:58,105 --> 00:49:01,372
call some complicated function on it, and get the result into
调用非常复杂的函数，取得结果

907
00:49:01,441 --> 00:49:06,044
a new array. So by creating a really powerful argument there
放入新数组。这需要创建一个非常强大的函数作为参数

908
00:49:06,112 --> 00:49:09,014
instead of String($0), something more powerful, you
替代 String($0)

909
00:49:09,083 --> 00:49:11,950
can really have one line of code that's really expressive.
你可以创造出意义丰富的单行代码

910
00:49:12,019 --> 00:49:15,587
It can do a lot of things. One thing about this one: notice
可以做很多事情。注意这个地方

911
00:49:15,656 --> 00:49:19,224
that after the word map, there's no parentheses,
map 的后面没有小括号

912
00:49:19,293 --> 00:49:21,259
no open parentheses. Did you notice that?
没有左半小括号，注意到了吗？

913
00:49:21,328 --> 00:49:23,795
You see the difference between filter and map, okay?
你们是否注意到了 filter 和 map 的区别

914
00:49:23,864 --> 00:49:25,931
When I called filter, I said open parentheses,
当我调用 filter 时，我在后面写了个小括号

915
00:49:25,999 --> 00:49:28,634
open curly brace, the function, curly brace, close
然后是大括号，函数，大括号结束，小括号结束

916
00:49:28,703 --> 00:49:34,506
parentheses. Here I just say, { String$0}, no parentheses.
但是 map 这里，我只是用了 { String($0) }，没有小括号

917
00:49:34,575 --> 00:49:38,910
And this is what's called the trailing closure syntax. You
这种语法叫做尾随闭包

918
00:49:38,979 --> 00:49:42,981
are allowed to have closures that are the last argument to
当闭包作为最后一个参数时

919
00:49:43,050 --> 00:49:46,384
a function. The outside of the parentheses of that function,
你可以把闭包放到函数的参数部分的括号的外边

920
00:49:46,453 --> 00:49:49,621
if they're trailing, see they're trailing the call. And
如果是尾随闭包，它们跟在函数调用的尾部

921
00:49:49,690 --> 00:49:51,723
in fact, if there's only one argument and
实际上，如果只有一个参数

922
00:49:51,792 --> 00:49:53,759
it's closure, you don't need the parentheses at all.
并且这个参数是闭包，连小括号都不需要了

923
00:49:53,828 --> 00:49:55,560
And that's what happened there with map.
这种情形就是 map 这行代码这样

924
00:49:55,629 --> 00:49:59,130
I'm just saying map, parentheses get rid of them.
只是说 map，省略了小括号

925
00:49:59,199 --> 00:50:02,368
Just put the closure there, trailing. And
把闭包跟在后面

926
00:50:02,436 --> 00:50:04,436
that also results in some pretty cool looking
产生了像这行代码一样的很酷的效果

927
00:50:06,473 --> 00:50:09,641
code right here, you see that? So you can use that anywhere
你们理解了吗？你们可以在任何地方

928
00:50:09,710 --> 00:50:12,944
that a closure is the last argument of function.
用这个语法，只要最后一个参数是函数

929
00:50:13,013 --> 00:50:15,713
You can take it outside, just put the curly braces. Cuz you already
你可以把闭包从小括号中提出来，只留下大括号这部分

930
00:50:15,782 --> 00:50:17,449
got the curly braces, and that's why they do it.
因为已经有大括号扩起来了，所以语法允许

931
00:50:17,517 --> 00:50:19,951
You don't really need the parentheses around it as well.
周围的小括号也不需要了

932
00:50:20,020 --> 00:50:20,786
So put that at the end.
把闭包直接放在尾部

933
00:50:20,854 --> 00:50:22,554
And put all the rest of the arguments, if you had them,
如果有其他参数的话

934
00:50:22,623 --> 00:50:27,158
inside the parentheses right before. This last one, I won't
仍然把它们放在小括号内。最后一个

935
00:50:27,227 --> 00:50:29,061
go into the details, but it's a similar kind of thing.
我不会深入讲解，不过这个和前面的 map 是类似的

936
00:50:29,129 --> 00:50:32,097
Reduce: what reduce does is it takes an entire array and
reduce，它的功能是将整个数组

937
00:50:32,165 --> 00:50:36,200
reduces it to a single value. So here I'm reducing it by
变成一个值，这里我把

938
00:50:36,269 --> 00:50:39,737
adding all the numbers in the array up. So my closure is $0
整个数组的数字都加起来，闭包写作 $0 + $1

939
00:50:39,806 --> 00:50:43,408
+ $1, because the argument it takes is a function that takes
因为这个参数是有两个参数的函数

940
00:50:43,477 --> 00:50:46,245
two elements. One of them is an element from the array and
其中一个是数组中的一个元素

941
00:50:46,313 --> 00:50:49,247
the other is the answer so far, and
另一个是目前为止累计的结果

942
00:50:49,316 --> 00:50:52,317
then it returns the new answer so far. So it just executes
然后它返回新的结果

943
00:50:52,385 --> 00:50:55,453
that function over and over and over on the arrays.
所以 reduce 对数组不断地执行这个函数

944
00:50:55,522 --> 00:50:58,957
By the way, notice that I can say this as sum = [1,
注意到了吗，我也可以写成 let sum = [1,2,3].reduce(0, +)

945
00:50:59,026 --> 00:51:03,228
2, 3].reduce(0, +) which is my starting so far value.
0 代表初始的迭代值

946
00:51:03,297 --> 00:51:06,064
Which I haven't added a name on, so it starts at 0 and
它没有参数名，所以会从零开始

947
00:51:06,133 --> 00:51:09,200
then I can say plus. The reason I can say plus right
然后我可以只写个加号，最下面这行代码

948
00:51:09,269 --> 00:51:11,803
there at the bottom line, is because plus
可以直接写个加号的原因是

949
00:51:11,872 --> 00:51:14,406
in Swift is not some kinda weird built-in thing,
加号在 Swift 中不是什么特殊的内置的符号

950
00:51:14,474 --> 00:51:18,076
it's just a function. It's a function that happens to be
它仅仅是个函数。是这样一个函数

951
00:51:18,145 --> 00:51:20,745
declared in a way that says, this is a function, but
它是这样声明的，这是个函数

952
00:51:20,814 --> 00:51:23,348
it's two arguments it's going either side of it.
它的两个参数就是加号两侧的值

953
00:51:23,417 --> 00:51:28,453
It's called an infix operator on a function. So
这叫做 infix（中缀）操作符函数

954
00:51:28,521 --> 00:51:30,255
since plus is just a function, and
因为 + 是个函数

955
00:51:30,324 --> 00:51:31,556
I'm taking a function as an argument,
我把一个函数作为这里的参数

956
00:51:31,625 --> 00:51:34,826
as long as it's a function that takes two arguments and
因为它是一个接受两个参数

957
00:51:34,895 --> 00:51:37,962
returns one, which is exactly what plus does, it works
返回一个值的函数，就和加法运算是一致的

958
00:51:38,031 --> 00:51:40,265
there. We could have done that in our calculator brain, too.
所以它可以用在这里，也可以用在 CalculatorBrain 中

959
00:51:40,334 --> 00:51:45,003
Remember all that closures we were doing ($0* $1),
还记得那些形如 $0 * $1 的闭包吗

960
00:51:45,072 --> 00:51:50,909
that could've just been *), ($0+$1), that could've just
它可以被简化为 *，$0 + $1 可以被简化为 +

961
00:51:50,978 --> 00:51:54,813
been +. Cuz + is a function that takes two doubles and
因为 + 是一个函数，接受两个 Double 作为参数

962
00:51:54,882 --> 00:51:58,416
returns a double. Plus also know how to plus other types,
返回一个 Double，+ 也懂得怎么操作其他类型

963
00:51:58,485 --> 00:52:01,619
ints. And it even knows how to plus and into a float,
比如 Int，Float 也可以

964
00:52:01,688 --> 00:52:05,356
for example, etc. You can plus strings together.
你还可以对两个 String 相加

965
00:52:05,425 --> 00:52:07,525
So that was just a little aside just to give you
再说就有点远了，这里只做简单的介绍

966
00:52:07,594 --> 00:52:11,162
an introduction there. You're gonna start seeing a lot of
你还会看到很多方法

967
00:52:11,231 --> 00:52:12,631
methods that take functions as arguments.
它们的参数是有两个参数的函数

968
00:52:12,700 --> 00:52:15,667
So I want you to start to get comfortable with that.
我希望你们逐渐适应这种方式

969
00:52:15,736 --> 00:52:19,204
Okay, dictionary. So we learned a lot about dictionary
好了，下面讲 Dictionary（字典）。在第一讲中

970
00:52:19,273 --> 00:52:22,140
in our first lecture. Dictionary also has this
我们已经学了不少有关字典的知识了

971
00:52:22,208 --> 00:52:25,977
special declaration syntax, which is open square bracket
字典也有这种特殊的声明语法

972
00:52:26,046 --> 00:52:30,882
key type colon value type closed square bracket. So
左半方括号，键类型，冒号，值类型，右半方括号

973
00:52:30,951 --> 00:52:34,386
those two things in yellow are equivalent.
所以两个标注为黄色的部分是等价的

974
00:52:34,455 --> 00:52:36,755
And the one on the bottom seems to be the preferred
目前第二个好像更受欢迎一些

975
00:52:36,823 --> 00:52:41,960
one these days. So you know you can create a dictionary.
你们已经知道了能创建一个字典

976
00:52:42,029 --> 00:52:44,796
By the way, I show you creating dictionaries from
我这里展示的是如何通过常量

977
00:52:44,865 --> 00:52:46,198
kind of constant values here.
来创建一个字典

978
00:52:46,267 --> 00:52:48,667
But you can create a dictionary just by saying,
但是你也可以先创建空字典

979
00:52:48,736 --> 00:52:50,802
let d equal dictionary. Open parenthesis,
比如 let d = [String:Int]()

980
00:52:50,871 --> 00:52:53,405
close parenthesis. And if you say var d
或者是创建可变的字典的变量

981
00:52:53,474 --> 00:52:55,941
equals dictionary, then now you can start appending items
比如 var d = [String:Int]()

982
00:52:56,009 --> 00:52:58,176
onto it because you get an empty dictionary to start. But
可以之后再往里面加东西

983
00:52:58,245 --> 00:53:01,012
here I'm starting my dictionary with stuff in it.
这里我初始化字典时就包含了一些内容

984
00:53:01,081 --> 00:53:06,051
That probably should say var pac12teamRankings
这里应该用 var pac12teamRankings 而不是 let

985
00:53:06,119 --> 00:53:10,154
because two lines later I say pac12teamRankings sub Cal
因为隔了两行代码之后

986
00:53:10,223 --> 00:53:15,159
equals 12. Note also that
我用了 pac12teamRankings["Cal"] = 12

987
00:53:15,228 --> 00:53:18,964
when I try to get the ranking of Ohio State, it returns nil.
另外注意我尝试获取键为 "Ohio State" 的值，返回的是 nil

988
00:53:19,032 --> 00:53:21,032
And we know that when we use square brackets to get
我们知道当用方括号

989
00:53:21,101 --> 00:53:22,367
something out of the dictionary, it returns
在字典中查询某个键时

990
00:53:22,436 --> 00:53:26,838
an optional of our value type. Our value type here is ints,
返回的是值类型的可选类型，这里我们的值类型是 Int

991
00:53:26,907 --> 00:53:32,544
so it's gonna return an optional int.
所以返回的是 Int?

992
00:53:32,613 --> 00:53:37,683
Alright, enumeration. A dictionary is also
下面是字典的枚举。字典也是一个 Collection

993
00:53:37,751 --> 00:53:40,852
a collection and thus can be sequenced. So you can do for
因此也是 Sequence，所以可以用 for...in 循环

994
00:53:40,921 --> 00:53:43,388
in on it. Of course, a dictionary has keys and
字典包含键和值

995
00:53:43,457 --> 00:53:48,326
values. So we need a tuple to do our enumeration for
所以我们要用一个元组来枚举

996
00:53:48,395 --> 00:53:52,964
the tuple key common value in the dictionary. And
写作 for (key, value) in dictionary

997
00:53:53,033 --> 00:53:56,468
then it'll go through and key in value will be set.
然后这个循环就开始了，会遍历所有的键值对

998
00:53:57,605 --> 00:53:59,104
It's a perfectly straightforward way
用这种方式对字典进行枚举或迭代

999
00:53:59,173 --> 00:54:04,643
to enumerate or iterate over a dictionary. Okay,
很完美，而且容易书写

1000
00:54:04,711 --> 00:54:08,547
String. So string, you would think, is the simplest class
String，你可能会认为

1001
00:54:08,615 --> 00:54:11,182
in all of any language. It's just a string, right?
String 是所有编程语言中最简单的类，它仅仅是个字符串

1002
00:54:11,251 --> 00:54:14,752
Well, that turns out not to be so true. When you think of
但是这种想法可能不那么正确

1003
00:54:14,821 --> 00:54:17,756
a string that represents every language in the entire world,
想象一下当一个字符串可以表达世界上所有语言的时候

1004
00:54:17,824 --> 00:54:21,760
all of a sudden it got real complicated real fast.
它突然间就变得复杂了

1005
00:54:21,828 --> 00:54:26,397
Because some languages are ideographic. Some languages go
因为一些语言是表意的

1006
00:54:26,466 --> 00:54:29,735
right to left instead of left to right. Some languages have
还有一些语言是从右往左书写的

1007
00:54:29,803 --> 00:54:34,639
a lot of diacritic marks and accents in them. Some don't.
一些语言有很多变音符或重音符，而另外一些没有

1008
00:54:34,708 --> 00:54:37,976
Most languages don't use the same alphabet as we use.
绝大多数语言和我们用的字母表不一样

1009
00:54:38,045 --> 00:54:40,412
So string is super complicated,
所以字符串其实非常复杂

1010
00:54:40,480 --> 00:54:43,982
this is a very complicated class. Now string tries
这是一个非常复杂的类

1011
00:54:44,050 --> 00:54:46,485
its best and does a pretty good job of simplifying it for
String 尽其所能让我们操作字符串变得容易

1012
00:54:46,553 --> 00:54:51,423
your use. But the complexity is still there. Now the most
但是复杂性还是存在的

1013
00:54:51,491 --> 00:54:54,393
important complexity about a string is that representing
String 最复杂的是

1014
00:54:54,462 --> 00:54:59,631
a string is not always one character equals one
显示的每一个字符

1015
00:54:59,699 --> 00:55:04,269
internal representation unit. Now the units, the kind of
并不是都能用一个字节表示的

1016
00:55:04,338 --> 00:55:06,804
thing that's used to represent strings on the inside,
String 内部用来表达一个字符串的编码

1017
00:55:06,873 --> 00:55:10,642
are Unicodes. I had you skip that reading in assignment
叫做 Unicode。在作业一中，我让你们跳过阅读这部分

1018
00:55:10,711 --> 00:55:13,344
one, I'm putting it in for assignment two.
现在我把这部分放在了作业二中

1019
00:55:13,413 --> 00:55:14,980
It's really not that critical that you understand it.
理解这部分内容并没有那么重要

1020
00:55:15,049 --> 00:55:16,248
I think it's very interesting, though, so
但是我觉得这是个很有趣的东西

1021
00:55:16,317 --> 00:55:19,918
you probably want to read it. But the thing about Unicodes
所以你可能愿意去阅读这些

1022
00:55:19,987 --> 00:55:22,420
is it's not one Unicode equals one character.
Unicode 的一个特点是，一个 Unicode 不等价于一个字符

1023
00:55:22,489 --> 00:55:27,392
In fact, if you have like a little emoji of a dog barking,
比如有一个类似狗叫的表情

1024
00:55:27,461 --> 00:55:30,562
that might be three Unicode characters. It's only one with
它很可能是由三个 Unicode 字符表达的

1025
00:55:30,630 --> 00:55:32,631
regards to what you perceive to be a character. Or
但看起来，它就是一个字符

1026
00:55:32,700 --> 00:55:36,902
even more simply, the example I have here, the word cafe.
来看个更简单的例子，café 这个单词

1027
00:55:36,970 --> 00:55:40,371
It's got e accent aigu on the end, right, it's a French
它的结尾有个闭音符，它是一个法语词

1028
00:55:40,440 --> 00:55:43,242
word, e accent aigu. That could be four Unicodes,
以 é 结尾。这个词可能是由 4 个 Unicode 构成的

1029
00:55:43,310 --> 00:55:45,710
because there is a Unicode for e accent aigu.
有一个单独的 Unicode 代表 é

1030
00:55:45,779 --> 00:55:49,548
Or it could be five. It could be the e with another Unicode
也有可能是由 5 个 Unicode 构成的。可能是 e 加上另一个

1031
00:55:49,616 --> 00:55:52,617
character that says put an accent on that previous
表达“给前面那个字符加上闭音符”这样含义的 Unicode

1032
00:55:52,686 --> 00:55:57,489
character. So, when you have this kind of unknown how many
当你不知道到底有多少字符来表达它的时候

1033
00:55:57,558 --> 00:56:00,325
characters it represents, you need a new abstraction
你需要一个新的抽象概念

1034
00:56:00,394 --> 00:56:04,495
to represent what we perceive as humans to be a character.
来表达我们人类认知上的字符

1035
00:56:04,564 --> 00:56:07,833
Even that is difficult to truly define, when you think
要针对世界上所有语言，定义出这种抽象概念非常困难

1036
00:56:07,901 --> 00:56:09,734
of all the languages in the world. It's easy in English,
只是针对英语的话很简单

1037
00:56:09,803 --> 00:56:15,274
though. So that's really how we're gonna interact with
这就是我们使用 String 的方法

1038
00:56:15,342 --> 00:56:17,976
strings: to try to think of them in terms of characters.
把它视作一串人类认知上的字符

1039
00:56:18,045 --> 00:56:19,711
But a string itself is not actually
但是 String 本身并不是

1040
00:56:19,780 --> 00:56:20,712
a collection of characters.
单纯的字符的集合

1041
00:56:20,781 --> 00:56:23,181
A string is a more powerful internal structure,
String 是一个内部非常强大的结构体

1042
00:56:23,250 --> 00:56:25,783
it's got all the Unicodes in there and all that stuff,
它包含了一串字符中所有的 Unicode 和其他东西

1043
00:56:25,852 --> 00:56:29,087
it's not quite that. And that makes for a little bit of
和你想象的不太一样

1044
00:56:29,156 --> 00:56:34,225
complication as you're gonna see. Now, you can't; String is
因此在使用 String 的时候还有其他不便之处

1045
00:56:34,294 --> 00:56:37,229
indexable which means you can use the open square brackets
虽然 String 可以用类似索引数组的形式

1046
00:56:37,297 --> 00:56:40,665
just like you can in array to get one of the characters.
通过方括号取得字符串中的某个字符

1047
00:56:40,734 --> 00:56:43,736
The only rub is what I said on the other slide that index
我之前提到过会带来的麻烦是

1048
00:56:43,804 --> 00:56:46,505
is not an int. So if you have the word hello,
String 的索引不是一个 Int 类型。你有一个单词 hello

1049
00:56:46,573 --> 00:56:53,378
it's not like you can say, hello[1] equals e.
你没法通过类似 hello[1] 的方式来取得字符 e

1050
00:56:53,447 --> 00:56:56,481
You can't do it that way because it might,
你没法那样做，因为可能有这种情况

1051
00:56:56,550 --> 00:56:59,050
if it was cafe then cafe sub 3.
如果这个单词是 café，然后取 café[3]

1052
00:56:59,119 --> 00:57:03,088
It's not clear. You want a character at that point
String 并不清楚你想要的是第四个字节还是整个字符

1053
00:57:03,157 --> 00:57:06,258
so you've got to make sure you get the right index in there
同时你还要确保自己提供的了正确的索引

1054
00:57:06,326 --> 00:57:08,961
because that index behind the scenes can be quite
因为这个索引位置的背后，实际上非常复杂

1055
00:57:09,029 --> 00:57:11,997
complicated. There's this other struct for it, which is
因此产生了另外一个结构体，叫做 String.Index

1056
00:57:12,065 --> 00:57:15,267
called a String.Index. So let's say I had a string,
我有一个字符串

1057
00:57:15,336 --> 00:57:18,870
which I'm gonna call s and I'm gonna put hello into there.
命名为 s，然后我把 "hello" 赋值给它

1058
00:57:18,939 --> 00:57:23,842
Now, what if I wanted s[0] now, I can't do s[0],
现在，我要取得 s[0]，当然没法写作 s[0]

1059
00:57:23,911 --> 00:57:25,678
because we don't index strings by integers but
因为没法通过整数来索引字符串

1060
00:57:25,746 --> 00:57:28,046
let's say I want that. How do I get it? Well,
我要那个字符，到底怎么拿到它？

1061
00:57:28,115 --> 00:57:31,450
I start by calling this var, again using this var and
首先我操作 s，调用 s.startIndex

1062
00:57:31,518 --> 00:57:34,386
string called startIndex, okay? It gives us
它返回给我一个 String.Index 类型的值

1063
00:57:34,455 --> 00:57:37,322
a string.index. It's very important, we need to get
下面很关键，我们需要一个变量保存这个 String.Index

1064
00:57:37,391 --> 00:57:39,958
a hold of a string.index because the way we're gonna
因为我们接下来要在字符串中

1065
00:57:40,027 --> 00:57:42,427
move around in string is by taking index we know and
以这个已知的索引为基准

1066
00:57:42,496 --> 00:57:44,963
moving forward or backward by character, by human
以人类认知的字符为单位向前或者向后移动

1067
00:57:45,032 --> 00:57:47,666
understandable character. Not by Unicodes, because we
不是以 Unicode 为单位

1068
00:57:47,734 --> 00:57:50,068
don't know how many Unicodes there are per character but
因为我们不知道每个字符到底用了几个 Unicode 来表达

1069
00:57:50,137 --> 00:57:52,637
by character, we're gonna be moving back and forth.
我们只根据字符来前后移动

1070
00:57:52,706 --> 00:57:54,506
So we start with this first one.
所以我们从第一个开始

1071
00:57:54,574 --> 00:57:56,941
And so now I can create a variable firstChar which is of
现在我创建一个变量叫做 firstChar

1072
00:57:57,010 --> 00:57:57,976
this type Character,
它是 Character 类型的

1073
00:57:58,045 --> 00:58:00,746
that human understandable character.
是人类认知上的字符

1074
00:58:00,814 --> 00:58:03,715
That's gonna be equal s[firstIndex]. So see look,
它将被赋值成 s[firstIndex]

1075
00:58:03,784 --> 00:58:06,552
I've used square brackets to index into a string, but
看，这里我用了方括号来索引字符串

1076
00:58:06,620 --> 00:58:10,722
I had to use a String.Index not an Int. This first index
我必须用 String.Index 而不是 Int 类型

1077
00:58:10,791 --> 00:58:13,091
I got by asking the string "what's your first index"?
我得到字符串的第一个索引，还要先问它才行

1078
00:58:13,160 --> 00:58:15,160
Well this is kinda useless because I have to ask
这个步骤感觉挺多余的

1079
00:58:15,228 --> 00:58:17,161
the string, what's the index of your first character and
我先向字符串索要它的第一个字符的索引之后

1080
00:58:17,230 --> 00:58:19,731
then turn around say okay give me S of your first character.
然后又说“好吧，我实际上要的是你的第一个字符”

1081
00:58:19,800 --> 00:58:20,899
So that's not the interesting thing,
这种方式一点也不有趣

1082
00:58:20,968 --> 00:58:23,835
what if I want the next character. If I
如果我要下一个字符呢?

1083
00:58:23,904 --> 00:58:27,006
want the next character, I ask the string what's the index of
如果我要下一个字符，我要对字符串说

1084
00:58:27,074 --> 00:58:30,975
the character after your first character. And
“你的第一个字符之后的字符的索引是什么”

1085
00:58:31,044 --> 00:58:33,178
it'll give me a new index, of its second character and
它会给我一个新的索引，即它第二个字符的索引

1086
00:58:33,247 --> 00:58:37,215
now I can get that one. Even that is a little bit like,
这样我才能拿到第二个字符。这种感觉就像是

1087
00:58:37,284 --> 00:58:38,049
my God, you're kidding me,
大地母亲在忽悠着我

1088
00:58:38,118 --> 00:58:41,219
this is really how I have to do this? What if I wanted
我真的只能这么做吗?

1089
00:58:41,288 --> 00:58:44,056
to go jump ahead though, and get the fourth, the fifth
我想跳过前面的字符，直接取得第四个，第五个怎么办？

1090
00:58:44,124 --> 00:58:47,959
character, let's say? Well I can jump ahead by saying s,
我们要这样做：对字符串 s 说

1091
00:58:48,028 --> 00:58:52,197
give me the index of, starting at your first index,
“从你的第一个索引开始”

1092
00:58:52,266 --> 00:58:53,832
that's four ahead so jump four ahead,
因为要跳到第四个，所以“往前跳四下”

1093
00:58:53,901 --> 00:58:58,770
four characters ahead. This is all a little
这样它就前进了四个字符

1094
00:58:58,839 --> 00:59:01,706
tedious and of course this is not the actual way that we're
这实在够无聊的，当然这不是我们和 String 打交道的常见方式

1095
00:59:01,775 --> 00:59:03,775
interacting with strings. We're usually looking for
我们常用的是寻找子串

1096
00:59:03,844 --> 00:59:07,346
substrings, okay, or subranges of characters or
或者子串所处的位置

1097
00:59:07,414 --> 00:59:09,281
we're trying to find a character in a string.
或者寻找一个字符串中是否存在某个字符

1098
00:59:10,684 --> 00:59:13,485
By the way, you can use ranges, so I could say
顺便，在这里你可以用 Range，所以可以说

1099
00:59:13,554 --> 00:59:17,021
give me the substring which is firstIndex...secondIndex and
给我 firstIndex...secondIndex 区间的子串

1100
00:59:17,090 --> 00:59:21,460
it would give me he. A new string which is he, so
这样它会返回我 "he"。一个新字符串 "he"

1101
00:59:21,528 --> 00:59:25,330
you can use ranges there but they have to be string.index
所以这里你可以用 Range，但必须是 String.Index 类型的

1102
00:59:25,398 --> 00:59:29,968
not ints. So we want basically something that
而不是 Int 类型的。所以我们更希望的是

1103
00:59:30,037 --> 00:59:34,673
is a collection of characters. A string is not a collection
操作一串字符的集合。String 不是字符的集合

1104
00:59:34,742 --> 00:59:37,709
of characters so you can't do for in, for example, on it.
所以你没法对它用 for...in 遍历

1105
00:59:37,778 --> 00:59:39,178
You can't even say index(of:).
你也没法对它用 index(of:) 方法

1106
00:59:39,246 --> 00:59:42,714
index(of:) is this great thing where you can,
index(of:) 对于一个集合而言非常好用

1107
00:59:42,783 --> 00:59:44,215
if you have a collection of things, you can say give
你可以说

1108
00:59:44,284 --> 00:59:47,452
me this index of this thing in there. You can't even do that
把这个元素的索引找出来

1109
00:59:47,521 --> 00:59:50,656
with a string because it's not a collection. Luckily,
但是你没法对 String 这样做，因为它不是 Collection

1110
00:59:50,724 --> 00:59:53,858
string has a var which will give you a collection of its
幸运的是，String 有一个变量

1111
00:59:53,927 --> 00:59:56,228
characters. And not only is it gonna give
不仅返回给你一个它包含的字符的集合

1112
00:59:56,297 --> 00:59:58,964
you a collection of its characters that you can for
你还可以对这个字符集合用

1113
00:59:59,032 --> 01:00:02,768
in over and do index(of:), but the string indexes you get
for...in 循环，或者调用 index(of:)，而且你通过这个集合

1114
01:00:02,836 --> 01:00:07,472
from that collection will match what's in the string. So
索引到的字符和字符串中实际包含的字符是匹配的

1115
01:00:07,541 --> 01:00:10,008
you can use this collection of characters to find things in
所以你可以用这个字符集合来查找字符

1116
01:00:10,077 --> 01:00:13,378
there, get the index of a character, things like
或者取得某个字符的索引，等等

1117
01:00:13,447 --> 01:00:15,947
that. And then use the indexes you find there to go back to
然后拿着你找到的索引，对原字符串说

1118
01:00:16,016 --> 01:00:20,752
your string and say, okay now give me a substring. So
现在给我一个指定的子串

1119
01:00:20,821 --> 01:00:24,890
characters is the name of this var on string. So for example,
String 下的这个变量名字叫做 characters

1120
01:00:24,958 --> 01:00:27,993
if I want to iterate over all the characters one by one,
举例来说，如果我要所有的字符，一个挨一个

1121
01:00:28,062 --> 01:00:29,828
do a for loop over them I can say, for c:,
用 for 循环遍历它们，我可以这样说

1122
01:00:29,897 --> 01:00:31,730
which will be of type character,
for c: Character in s.characters

1123
01:00:31,798 --> 01:00:36,334
by the way, in s.characters. I can't say for c: in s, for
我不能说 for c in s

1124
01:00:36,403 --> 01:00:40,372
c: in s.characters. And that's just gonna call my for
必须说 for c in s.characters

1125
01:00:40,441 --> 01:00:43,308
loop once with each character. Question? Yeah,
这样就能通过 for 循环变量遍历每一个字符了。有什么问题？

1126
01:00:43,377 --> 01:00:46,211
great question. So if I do this over cafe,
问得好！如果我对 café 做 for 循环

1127
01:00:46,279 --> 01:00:49,580
what am I gonna get? I'm gonna get four characters, okay,
我会得到什么？我会得到四个字符

1128
01:00:49,649 --> 01:00:52,150
because that E-accent-agu that they use is considered in our
因为 é 被视作

1129
01:00:52,219 --> 01:00:54,520
human perception one character.
一个人类认知中的字符

1130
01:00:54,588 --> 01:00:56,454
I'll get four characters. So there is a character.
我会得到四个字符，有一个 Character

1131
01:00:56,523 --> 01:00:58,423
Characters are struct, right? And in the character
Character 是结构体，Character 中刚好

1132
01:00:58,491 --> 01:01:01,093
there is a character that represents e-accent-agu.
有一个能代表 é

1133
01:01:01,161 --> 01:01:02,360
No matter how it's represented in the string,
不论它在 String 内部是怎么表达的

1134
01:01:02,429 --> 01:01:03,895
in the string it might be two characters, it might be one,
也许是两个字符，也许是一个

1135
01:01:03,964 --> 01:01:06,565
it doesn't matter. You're gonna get the one character
都没有关系。因为你得到的是一个能代表它的 Character

1136
01:01:06,634 --> 01:01:09,567
for it, so that's a really good question. How would I
这个问题问得好

1137
01:01:09,636 --> 01:01:12,537
know how many characters there are in a string? Again,
我怎么才能知道到底一个字符串中有多少字符？

1138
01:01:12,606 --> 01:01:14,973
from the user perspective. s.characters.count,
人类认知的字符。s.characters.count

1139
01:01:15,042 --> 01:01:18,243
not s.length or something, s.characters.count,
不是 s.length 或者其他什么，就是 s.characters.count

1140
01:01:18,312 --> 01:01:21,679
the count of the characters in the collection of characters
意思是在这个字符串的字符集合中，元素的数量

1141
01:01:21,748 --> 01:01:26,250
for this string. Also, what if I want to find the first space
那么如果我要找字符串中的第一个空格怎么做？

1142
01:01:26,319 --> 01:01:29,121
in a string? Got a string with a bunch of words, I wanna find
有个字符串，它包含很多单词

1143
01:01:29,189 --> 01:01:34,559
the first space. I would say s.characters.index(of: " ").
我要找第一个空格。我应该用 s.characters.index(of: " ")

1144
01:01:34,628 --> 01:01:38,030
And that's giving me a string.index(of: " ") that
这会返回给我空格在字符集合中的索引

1145
01:01:38,098 --> 01:01:41,032
collection of characters. I can then use that string in
然后我可以利用这个索引

1146
01:01:41,101 --> 01:01:43,702
that index though to go back to my string and do something.
回到原字符串中做些什么事情

1147
01:01:43,771 --> 01:01:45,470
Maybe insert something there or
比如插入一些新字符

1148
01:01:45,539 --> 01:01:48,473
delete the word that's right after the space or insert
删除空格之后的那个单词

1149
01:01:48,542 --> 01:01:54,279
another space. I'll have the index into the string now.
或者插入另外一个空格。总之，我将会得到字符串的索引

1150
01:01:54,348 --> 01:01:58,850
String is a value type, so when you do let versus var,
String 是一个值类型，来对比下用 let 或 var 声明时的不同

1151
01:01:58,919 --> 01:02:02,420
if you do let you cannot do things like append on to
如果你用 let 声明，就没法做类似于 append 之类的操作

1152
01:02:02,489 --> 01:02:06,525
the string cuz it's immutable. Most strings in Swift
因为它是不可变的，Swift 中绝大多数字符串都是不可变的

1153
01:02:06,594 --> 01:02:09,027
are immutable, that makes it super high performance.
这使得它效率非常高

1154
01:02:09,096 --> 01:02:12,964
But if you have a var you can do greeting plus equals there
但是如果你用 var 声明 greeting，可以 greeting += " there"

1155
01:02:13,033 --> 01:02:16,235
and so I can have hello there. It doesn't have any effect on
然后得到字符串 "hello there"。这种操作不会改变 hello

1156
01:02:16,303 --> 01:02:19,304
hello, the let one because that's immutable, right? Okay,
因为 hello 是 let 声明的，不可变，明白了吗？

1157
01:02:19,373 --> 01:02:22,007
so I can't do that. And I can use the characters to
所以我没法对 hello 做类似的操作。我还可以通过 characters

1158
01:02:22,076 --> 01:02:24,876
manipulate strings in really powerful ways. I can, I don't
对字符串做出一些更强大的操作

1159
01:02:24,945 --> 01:02:27,279
have time to talk about all of it, this is where you really
我没时间讲解所有字符串操作相关的内容

1160
01:02:27,348 --> 01:02:29,915
do need to read your reading assignment carefully. But for
剩下的部分需要你们课后认真阅读

1161
01:02:29,984 --> 01:02:33,285
example if I want to insert the word you into hello there,
我就讲一个例子，如果我要在 hello 和 there 中间

1162
01:02:33,353 --> 01:02:36,621
so it says hello you there, okay, I would just get the,
插入一个单词 you 变成 hello you there

1163
01:02:36,690 --> 01:02:40,425
find the first space by doing characters.index(of: " "),
我要先通过 characters.index(of: " ") 找到第一个空格

1164
01:02:40,494 --> 01:02:43,762
which I showed you on the previous slide. Then there's
这个用法上一页我已经展示了

1165
01:02:43,831 --> 01:02:47,199
a method in string called, insert the constant,
然后 String 有个方法叫做 insert(contentsOf:at:)

1166
01:02:47,267 --> 01:02:50,569
the content of this collection of characters
这个方法可以在指定的位置插入复数字符构成的集合

1167
01:02:50,638 --> 01:02:55,040
at this location, this string.index. So, when I want
指定的位置是 String.Index 类型

1168
01:02:55,108 --> 01:02:58,443
a collection of characters that represents " you", I say,
我要插入代表 " you" 的字符集合

1169
01:02:58,512 --> 01:03:02,080
" you".characters, because it's the .characters, and
所以这个应该写作 " you".characters

1170
01:03:02,149 --> 01:03:05,883
it gives me a collection of characters for that string. So
因为 .characters 是 " you" 对应的字符集合

1171
01:03:05,952 --> 01:03:09,021
it seems a little weird but It actually turns out to work out
这用法好像有点奇怪，但它确实能达到我要的结果

1172
01:03:09,089 --> 01:03:11,456
pretty well. And there's a billion other functions,
Swift 中还有非常多的函数

1173
01:03:11,525 --> 01:03:12,924
in Swift, many, many, many,
非常，非常，非常多

1174
01:03:12,993 --> 01:03:15,027
I can't talk about them all.
我没法每个都讲

1175
01:03:15,095 --> 01:03:18,396
Notice I say if let firstSpace, because that might
注意到这里我用了 if let firstSpace，因为有可能

1176
01:03:18,465 --> 01:03:21,166
return nil if it couldn't find it. So I wouldn't do it there,
没找到指定的内容，返回 nil 就不执行大括号内的代码

1177
01:03:21,234 --> 01:03:25,904
I wouldn't insert it there. Yeah a bunch of other things
也就不会对原字符串进行插入操作。这里还有一大堆其他方法

1178
01:03:25,972 --> 01:03:28,807
checking where strings have prefixes or not.
这个方法可以检查字符串是否包含某个前缀

1179
01:03:28,876 --> 01:03:31,109
You can replace subrange, of course you have to find
你可以替换子串，当然替换之前

1180
01:03:31,177 --> 01:03:33,044
the range which usually you're gonna have to look at that
你通常要通过访问字符串的字符集合

1181
01:03:33,113 --> 01:03:35,480
collection of characters to find the ranges you wanna
来确定要替换的范围

1182
01:03:35,549 --> 01:03:38,783
replace things etc. Even cool methods like components
更有趣的一个方法，你可以通过 components(separatedBy:)

1183
01:03:38,852 --> 01:03:42,020
separated by string will take a string that has like comma or
对包含逗号或者其他分隔字符的字符串

1184
01:03:42,089 --> 01:03:45,824
separated values and grab all of the values and
拆分得到所有子串

1185
01:03:45,893 --> 01:03:48,727
put them in an array which is kinda fun. Okay so
然后返回一个包含这些子串的数组

1186
01:03:48,796 --> 01:03:52,864
a lot: string has dozens and dozens of methods, you really
讲了这么多，String 还有很多很多方法

1187
01:03:52,933 --> 01:03:55,100
need to familiarize yourself. If you don't take the time to
你需要去熟悉它们

1188
01:03:55,168 --> 01:03:57,235
familiarize yourself with those thing in strings.
如果你不在这上面花时间的话

1189
01:03:57,304 --> 01:03:58,971
Then I guarantee you're going to be writing a program and
我保证有一天你会遇到这种情况，你在写一个程序的时候

1190
01:03:59,039 --> 01:04:01,006
you're going to want to do some string parsing or
需要对字符串进行解析或其他某种操作

1191
01:04:01,075 --> 01:04:02,641
something and you're going to write a whole bunch of
你写了一大段代码来完成这个功能

1192
01:04:02,710 --> 01:04:04,276
code to do it and then find out there was one method that
然后发现其实只要一个原生的方法

1193
01:04:04,345 --> 01:04:05,878
did exactly what you want in the string.
就能实现你想要的功能

1194
01:04:07,514 --> 01:04:09,281
There are things in there take closures and
有些方法会接受闭包

1195
01:04:09,350 --> 01:04:10,516
do all kinds of fun stuff so
然后做各种有趣的操作

1196
01:04:10,584 --> 01:04:12,984
make sure you pay attention to both to string and
所以你要同时留意 String

1197
01:04:13,053 --> 01:04:16,754
to the character view which is a collection of characters.
和 String.CharacterView，也就是字符的集合

1198
01:04:16,823 --> 01:04:21,894
All right, other classes. This is kind of quick summary here
好了，接下来讲讲其他类。快速过一遍其他重要的类

1199
01:04:21,962 --> 01:04:25,130
of other important classes. One is NSObject, NSObject is
第一个是 NSObject，它是

1200
01:04:25,199 --> 01:04:30,902
a class. It is the root of all Objective-C classes. An iOS
所有 Objective-C 类的根类

1201
01:04:30,971 --> 01:04:34,305
app written before a couple years ago when Swift came out,
Swift 诞生之前的许多年间

1202
01:04:34,374 --> 01:04:36,975
all the classes in there would inherit eventually from
iOS 应用中所有类都要继承自 NSObject

1203
01:04:37,044 --> 01:04:40,011
NSObject. So NSObject has a base functionality. You do not
NSObject 具有很多基础性的功能

1204
01:04:40,080 --> 01:04:43,214
need to subclass from NSObject to make a swift class.
Swift 中的类不需要继承自 NSObject

1205
01:04:43,283 --> 01:04:45,850
However there are some really obscure features still left in
但是，iOS 中残留有很多比较复杂的功能

1206
01:04:45,919 --> 01:04:50,622
iOS where to expecting a class that inherit from NSObject.
仍然需要使用继承自 NSObject 的类

1207
01:04:52,025 --> 01:04:54,759
If we even get to them, I'll show them to you. They're
等用到的时候，我再展示给你们

1208
01:04:54,828 --> 01:04:57,095
pretty rare. But that's just so you know what NSObject is.
这种情况不会太多。你们知道 NSObject 是什么就够了

1209
01:04:57,164 --> 01:04:58,364
Doesn't really have meaning to you,
这对你们意义不大

1210
01:04:58,432 --> 01:05:00,965
cuz you guys are gonna be Swift programmers.
因为你们将要成为的是 Swift 程序员

1211
01:05:01,034 --> 01:05:04,235
NSNumber is another class, it's a generic number
其次是 NSNumber，是一个通用的数字容器

1212
01:05:04,304 --> 01:05:08,072
holder. This is also inherited from Objective-C, you can tell
NS 前缀表明，它也是从 Objective-C 那边继承来的

1213
01:05:08,141 --> 01:05:12,077
by the NS there. Until we can hold any kind of number,
它可以持有任何类型的数字

1214
01:05:12,145 --> 01:05:14,479
floating point, decimal, you can even hold a bool,
浮点数，小数，甚至是布尔值

1215
01:05:14,547 --> 01:05:16,982
since it considers that a number where zero is false and
因为它会把 0 当作 false

1216
01:05:17,050 --> 01:05:20,685
one is true. Any nonzero is true. And you can also
把 1 当作 true，非零的都当作 true

1217
01:05:20,754 --> 01:05:25,390
do type conversions. Again, in swift, we're gonna be using
你还可以对它做类型转换。不过，再次强调，在 Swift 中

1218
01:05:25,458 --> 01:05:28,627
the actual concrete number classes like double an int and
我们更倾向于使用固定的数字类型，如：Double，Int

1219
01:05:28,696 --> 01:05:32,698
we'll use their constructors. To do type conversion.
我们通过这些类型的构造器来做类型转换

1220
01:05:32,766 --> 01:05:35,767
But just so that you know that NSNumber is around. Okay,
知道 NSNumber 这些就够了

1221
01:05:35,835 --> 01:05:38,670
date. Super important class. Anytime you are representing
Date 是一个非常重要的结构体。任何时候

1222
01:05:38,738 --> 01:05:42,674
a date or time, you're gonna wanna use this date struct.
你想表达一个日期或时间，都要用到 Date 这个结构体

1223
01:05:42,743 --> 01:05:46,144
And it has a lot of ancillary classes that go with it,
而且还有一系列和它相关的辅助结构体

1224
01:05:46,212 --> 01:05:49,914
like calendar, date formatter, date components like date
比如 Calendar，DateFormatter，DateComponents

1225
01:05:49,983 --> 01:05:52,551
components will tell you the month of a date. And
DateComponents 可以告诉你某个日期对应的月份

1226
01:05:52,620 --> 01:05:54,686
of course, what the month of is of a date depends on
当然，还要知道日期所处的历法，才能确定它对应的月份

1227
01:05:54,755 --> 01:05:58,123
the calendar it's in, cuz not everyone uses a calendar like
因为不是所有人都和我们用一样的历法

1228
01:05:58,191 --> 01:06:00,258
we do. All right, there's a lot of calendars
世界上有许多历法

1229
01:06:00,327 --> 01:06:02,528
all over the Earth that are different than ours.
和我们使用的历法不同

1230
01:06:02,596 --> 01:06:05,697
So anytime you're even contemplating putting a date
因此，当你考虑在界面上展示一个日期的时候

1231
01:06:05,766 --> 01:06:09,568
anywhere in your UI you need to be using this class.
都应该用这个结构体

1232
01:06:09,636 --> 01:06:12,270
Because if you wanna have your app work in anything but
如果你希望你的应用可以在非英语环境下正常工作

1233
01:06:12,339 --> 01:06:14,639
English, you're gonna have to format your date, using
你就必须用 DateFormatter 对日期进行格式化

1234
01:06:14,708 --> 01:06:19,744
the DateFormatter, in whatever locale your app is running in.
把日期用当地的习惯表达

1235
01:06:19,813 --> 01:06:22,514
So date is super important. You would think date is really
Date 非常重要，可能你之前低估了 Date

1236
01:06:22,583 --> 01:06:25,149
easy, but no. Date actually has a lot of complexity to it,
实际上 Date 非常复杂

1237
01:06:25,218 --> 01:06:27,352
because of all the different ways we represent dates in
因为世界上有许多种表达日期的方式

1238
01:06:27,420 --> 01:06:30,989
the world. Same, similar to strings complexity. And
这点和 String 的复杂性是类似的

1239
01:06:31,058 --> 01:06:35,060
then there's data, D-A-T-A, that represents a bag of bits.
然后是 Data，D-A-T-A，代表一串二进制数据

1240
01:06:35,129 --> 01:06:38,963
Just a bits, bunch of bits in there. Usually this might be
仅仅是一连串的二进制数据

1241
01:06:39,032 --> 01:06:42,066
something like an image, the bits of an image, or
它可能是个图片，图片的二进制数据

1242
01:06:42,135 --> 01:06:45,671
something like that. Something you get over the the network.
或者其他类似的东西，比如从网络获取的数据

1243
01:06:45,739 --> 01:06:47,806
So data is how we represent those.
这些东西我们都用 Data 来表达

1244
01:06:47,875 --> 01:06:49,875
Notice that there is a struct, it's a value type.
注意，它是个结构体，是值类型

1245
01:06:49,944 --> 01:06:54,045
It gets passed around copy on right. And
它通过值的复制来传递

1246
01:06:54,114 --> 01:06:56,882
you'll start seeing data in UI maybe week five or
你们将会在第五或第六周 UI 部分开始接触到它

1247
01:06:56,950 --> 01:07:00,686
six of this class. All right, initialization.
接下来是 Initialization（构造）

1248
01:07:00,754 --> 01:07:04,122
So initialization is very complicated. You're
构造非常复杂

1249
01:07:04,191 --> 01:07:07,092
gonna have to read the reading assignment on it eventually.
你们必须完成有关这部分的课后阅读作业

1250
01:07:07,161 --> 01:07:11,996
I'm gonna give you the really fast highlights of it. init
我只会帮你们快速过一遍重点

1251
01:07:12,065 --> 01:07:15,500
method, again, we can have them on classes or structs.
类或结构体都可以拥有构造器

1252
01:07:15,569 --> 01:07:18,670
They are used to initialize any of the properties that we
用来初始化那些

1253
01:07:18,738 --> 01:07:22,674
didn't initialize with equals or using lazy or they were
没有使用等号赋值或延时加载，也不是可选类型的属性

1254
01:07:22,742 --> 01:07:25,811
optionals. All those are taken care of and if there's one
如果有至少一个属性符合以上特点

1255
01:07:25,879 --> 01:07:30,649
left, or more than one left, then we need an initializer.
我们就必须创建一个构造器

1256
01:07:30,718 --> 01:07:33,618
To initialize it. And they're kind of a pain in the neck.
这个规则有时很烦人

1257
01:07:33,687 --> 01:07:36,655
Because, especially for classes. For structs,
尤其对类而言

1258
01:07:36,723 --> 01:07:39,023
they're not a pain in the neck. They are perfectly fine.
对结构体而言，则没有这种烦恼

1259
01:07:39,092 --> 01:07:41,727
Struct, you just have an init with whatever argue you want,
结构体中，你会自动得到一个构造器

1260
01:07:41,795 --> 01:07:43,328
arguments you want. And initialize your variables.
接受所有需要初始化的属性为参数，并初始化它们

1261
01:07:43,397 --> 01:07:46,564
It's all very simple. But for classes, it's a little more
这很简单吧。但是对类而言，就稍微有点复杂了

1262
01:07:46,633 --> 01:07:49,201
complicated. Now, whether you're a struct or a class,
不论是类还是结构体

1263
01:07:49,269 --> 01:07:51,603
you can have multiple init. And they can have different
都可以拥有多个构造器

1264
01:07:51,672 --> 01:07:55,106
arguments. As long as you give them enough arguments to be
并且可以接受不同的参数。只要确保传给它们的参数

1265
01:07:55,175 --> 01:07:58,710
able to initialize all their variables, you're good to go.
足够用来初始化它们的全部变量

1266
01:07:58,779 --> 01:08:00,278
So you can have as many inits as you want.
因此你想创建多少构造器都可以

1267
01:08:00,347 --> 01:08:02,914
And a lot of classes have multiple inits. Depending on
也确实有很多类都有不止一个构造器

1268
01:08:02,983 --> 01:08:04,649
kinda how they are being used, how they are being created.
创建过程取决于使用方式

1269
01:08:04,718 --> 01:08:06,217
Think of something like string.
以 String 为例思考一下

1270
01:08:06,286 --> 01:08:07,852
String has an init that takes a double.
String 有一个接受 Double 的构造器

1271
01:08:07,921 --> 01:08:09,888
It has a string that takes another string if you want to
它还有接受另一个字符串的构造器

1272
01:08:09,956 --> 01:08:12,190
make a copy of the string it turns out. It takes an Int.
如果你要一份原字符串的拷贝就可以用这个构造器。

1273
01:08:12,259 --> 01:08:14,727
It has all these things that you can convert to string.
它还可以接受 Int，以及所有可以转化为字符串的东西

1274
01:08:14,795 --> 01:08:16,929
Or not all the things you convert to string but
或许不是所有

1275
01:08:16,997 --> 01:08:18,496
a lot of things you can convert to a string.
但是相当多都是可以的

1276
01:08:18,565 --> 01:08:20,766
It has an initializer that it will take that as an argument
String 会有对应的构造器，接受对应类型的参数

1277
01:08:20,834 --> 01:08:26,538
for example. Callers execute your init by creating
调用者通过执行你的构造器

1278
01:08:26,606 --> 01:08:29,841
one of the thing. They just put the name of the type and
来创造一个对应的实例

1279
01:08:29,909 --> 01:08:33,211
parentheses and the arguments you want for that init. So
他们可以通过类型名和小括号，传入你要求的参数来构造

1280
01:08:33,280 --> 01:08:35,514
they pick which of your init that they want and
他们会选用合适的构造器

1281
01:08:35,583 --> 01:08:37,416
they call that one with those arguments.
调用那个构造器，传入指定的参数

1282
01:08:37,484 --> 01:08:40,519
We've seen many examples of this in our lecture, so far.
在这门课程中，我们已经遇到过很多这种例子了

1283
01:08:43,490 --> 01:08:48,192
You get some inits for free. If you're a base class, okay,
有一些构造器系统会帮你自动生成。如果你有个基类

1284
01:08:48,261 --> 01:08:50,395
you don't inherit from anything else.
它没有继承自任何其他类

1285
01:08:50,463 --> 01:08:53,832
You get a free init with no arguments. Congratulations.
你会自动得到一个不含参数的构造器

1286
01:08:53,901 --> 01:08:56,401
So that means, at least, people can create you.
恭喜你，这意味着起码别人可以创建这个类的实例

1287
01:08:56,470 --> 01:08:58,169
But, again, if you have any vars that aren't initialized,
但是，如果你有些变量没被初始化

1288
01:08:58,238 --> 01:09:00,405
you're gonna have to create your inits that initialize
你就必须创建一个构造器来初始化它们

1289
01:09:00,474 --> 01:09:05,143
them. Structs are even better. They get an init that has all
结构体更加方便，它们会自动生成一个包含所有变量的构造器

1290
01:09:05,212 --> 01:09:10,181
of their vars. Now if a struct implements even one of its own
如果你添加了任何一个自定义的构造器

1291
01:09:10,250 --> 01:09:13,452
initializers, it stops getting this one, this free one.
结构体就会失去自动生成的那个构造器

1292
01:09:13,520 --> 01:09:15,920
You only get the free one if you don't do any other ones.
只有当你没有添加任何别的构造器时，它才会自动生成一个

1293
01:09:15,989 --> 01:09:17,022
So it's like the default one.
它就像是一个默认构造器

1294
01:09:17,091 --> 01:09:19,124
And we saw this in the lecture also.
这种情况我们之前也遇到了

1295
01:09:19,192 --> 01:09:23,428
We got the free one in the init function, first operand.
我们自动获得了这个 init(function:firstOperand:) 构造器

1296
01:09:23,497 --> 01:09:26,231
We never wrote that init function, we got it for free.
我们从来没写过这个方法，完全是自动获得的

1297
01:09:26,299 --> 01:09:30,068
It just appeared and we were able to call it, remember that? so
它自然就存在了，我们也确实可以调用它，想起来了吗？

1298
01:09:30,137 --> 01:09:32,504
structure is nice you get the basic free init for
所以结构体很方便，你自动就获得了包含所有变量的构造器

1299
01:09:32,573 --> 01:09:37,275
all your vars. What can you do inside of a init? I'm
在构造器中可以做什么呢？

1300
01:09:37,344 --> 01:09:40,445
gonna start going fast here, okay. So here we go. One,
这部分我会加快速度

1301
01:09:40,514 --> 01:09:43,382
you can set any properties value even if that property
首先，你可以给属性赋值，即使它已经被赋过值了

1302
01:09:43,450 --> 01:09:46,185
already had its value set, you can reset something else.
你可以重新给变量赋成别的值

1303
01:09:46,253 --> 01:09:50,589
You can set lets. So you're gonna have a let that's
还可以初始化 let 声明的常量。比如有一个属性 let x = 5

1304
01:09:50,657 --> 01:09:54,826
got lets x equal 5. You can still reset it in your init.
构造器内仍然可以重设它（误：常量不能重新赋值）

1305
01:09:54,895 --> 01:09:59,330
Your init is allowed to set lets. You can call other init
所以构造器内只允许对常量属性赋初值

1306
01:09:59,399 --> 01:10:04,135
methods okay in your own class or your own struct. And you do
你还可以调用这个类或结构体的其他构造器

1307
01:10:04,204 --> 01:10:06,972
that by saying self.init with whatever the arguments to that
通过 self.init(<args>) 并且传入指定的参数来调用

1308
01:10:07,041 --> 01:10:10,175
init method are so init methods can call each other.
所以构造器是能互相调用的

1309
01:10:10,244 --> 01:10:13,278
In a class, you can call super.init.
在一个类的构造器中，你还能调用 super.init(<args>)

1310
01:10:13,347 --> 01:10:14,680
An initializer from your super class.
一个继承自父类的构造器

1311
01:10:14,748 --> 01:10:17,516
Of course you need to get your super class initialized.
这是理所当然的，你必须让父类也得以构造

1312
01:10:17,585 --> 01:10:19,517
Now, when we start talking about class though,
既然我们现在已经开始讨论类了

1313
01:10:19,586 --> 01:10:22,988
and we start talking about calling inits in our super,
并且提到调用父类的构造器

1314
01:10:23,057 --> 01:10:24,823
and we start thinking about inheritance,
我们就需要思考继承这个概念

1315
01:10:24,892 --> 01:10:27,859
it gets really complicated. So
这是个很复杂的概念

1316
01:10:27,928 --> 01:10:31,195
let's start thinking about class and break this down.
所以我们还是先思考类，不提继承

1317
01:10:31,264 --> 01:10:34,699
Let's start with what are you required to do in an init for
我们从这个问题切入：在类的构造器中必须做的是什么？

1318
01:10:34,768 --> 01:10:37,969
a class? in a struct it's easy you're just required to
在结构体中很简单

1319
01:10:38,038 --> 01:10:40,238
initialize all your vars that aren't initialized. But
我们只要把所有没被初始化的变量初始化就行了

1320
01:10:40,307 --> 01:10:43,809
in a class what are you required to do? By the time
但是在一个类中，我们必须做的事情有哪些？

1321
01:10:43,878 --> 01:10:46,345
it's done you have to have initialized all your vars.
你必须完成初始化所有变量的任务

1322
01:10:46,413 --> 01:10:50,048
We know that. There are two types of initializers.
这点我们已经知道了。存在两种构造器

1323
01:10:50,117 --> 01:10:51,583
A convenience initializer.
Convenience Initializer（便利构造器）

1324
01:10:51,651 --> 01:10:54,753
This is only for classes. A convenience initializer and
只有类才有便利构造器

1325
01:10:54,822 --> 01:10:57,055
what's called a designated initializer.
另一种被称为 Designated Initializer（指定构造器）

1326
01:10:57,124 --> 01:11:00,024
Designated is the default. There's no keyword it's just
不带任何关键词就会被默认为指定构造器

1327
01:11:00,093 --> 01:11:02,127
if it's not marked convenience then it's a designated.
如果没被标记为 convenience，它就是指定构造器

1328
01:11:02,195 --> 01:11:04,462
Now here's where the rules come in.
现在开始引入规则部分

1329
01:11:04,531 --> 01:11:08,133
A designated initializer non convenience must and
一个指定构造器，非便利构造器

1330
01:11:08,201 --> 01:11:12,870
can only, call the designated initializer that it is in,
必须调用且只能调用

1331
01:11:12,939 --> 01:11:15,974
that is in it's immediate superclass,
它直接继承的父类的指定构造器

1332
01:11:16,043 --> 01:11:19,478
it's very important. It has to call a superclass init
这点很关键，它必须调用父类的构造器

1333
01:11:19,546 --> 01:11:22,013
and it has to get designated initializer. It cannot call
并且必须是指定构造器

1334
01:11:22,082 --> 01:11:25,083
it's convenience initializer in a superclass. Nor
它没法调用父类的便利构造器

1335
01:11:25,152 --> 01:11:30,222
can it call two classes up the inherent chain unless the one
也没法调用继承关系中更上层的父类（的任何构造器）

1336
01:11:30,290 --> 01:11:32,691
right above inherited the init from the one up above, and
除非它的父类的构造器是继承自更上层父类的

1337
01:11:32,759 --> 01:11:36,094
we'll talk about that in a second. You have to initialize
这点我们过会再讲

1338
01:11:36,162 --> 01:11:39,898
all of your properties before you call that super init.
你必须初始化自身的所有属性，之后才能调用 super.init

1339
01:11:42,336 --> 01:11:43,435
You must have completely
你必须完完全全地

1340
01:11:43,504 --> 01:11:46,037
done all the ones that you introduced in your class.
把自己新引入的属性都初始化

1341
01:11:46,106 --> 01:11:48,740
Get them initialized before you call super init. And,
之后才能调用 super.init

1342
01:11:48,809 --> 01:11:51,809
you have to call the super one before you can reinitialize or
而且你只有在调用了 super.init 之后

1343
01:11:51,878 --> 01:11:54,846
change the value of any of its properties, obviously,
才能改变继承自父类的属性

1344
01:11:54,915 --> 01:11:57,816
you gotta let your super class have a chance to initialize
显然，你必须等你的父类把它自身构造完成

1345
01:11:57,885 --> 01:12:00,685
itself before you start mucking with its properties.
之后才能改变它的属性

1346
01:12:00,754 --> 01:12:03,322
Otherwise, when your inits call super, it's probably gonna
另外，当你初始化完毕自身的属性之后

1347
01:12:03,391 --> 01:12:05,557
be last whatever you did to its properties.
调用 super.init 通常就是你要做的最后一件事

1348
01:12:05,626 --> 01:12:10,862
A convenience init can only, must and can only,
一个便利构造器，必须且只能

1349
01:12:10,931 --> 01:12:16,268
call an initializer in its own class, no super.
调用其自身所在类的构造器，不能调用父类的构造器

1350
01:12:17,571 --> 01:12:18,603
Only in your own class,
只能是自身所在类的

1351
01:12:18,672 --> 01:12:22,040
convenience initializer only in your own class. You can
便利构造器只能调用自身所在类的构造器

1352
01:12:22,109 --> 01:12:24,109
call it another convenience or you can call it designator,
你可以在它内部调用其他便利构造器或者指定构造器

1353
01:12:24,177 --> 01:12:25,477
but it has to be in your own class,
但是都必须是你自身所在类的构造器

1354
01:12:25,546 --> 01:12:27,712
not in your super class. And
不能是父类的

1355
01:12:27,781 --> 01:12:30,682
a convenience init has to call whatever init it's gonna call
一个便利构造器必须先调用任何一个其他构造器

1356
01:12:30,751 --> 01:12:33,318
in itself before it can set any of the property
之后才能设置属性

1357
01:12:33,387 --> 01:12:37,189
values. It's kind of different from an init that calls into
这和构造器中调用父类构造器的情形相反

1358
01:12:37,258 --> 01:12:39,491
super because that one has to do its initialization,
指定构造器必须先初始化自身新引入的属性

1359
01:12:39,560 --> 01:12:41,426
the designated one, before it calls super.
然后才能调用父类的构造器

1360
01:12:41,495 --> 01:12:43,595
This, in this case, you have to do convenience,
但是到了便利构造器这里

1361
01:12:43,664 --> 01:12:46,164
you have to call your other one first.
你必须先调用一个自身的其他构造器

1362
01:12:46,232 --> 01:12:50,969
And the calling of all other inits, whatever you do, any
任何其他构造器，无论哪个都行

1363
01:12:51,037 --> 01:12:54,539
inits that you have to call has to be done in all cases,
任何情况下，在完成某个构造器的调用之后

1364
01:12:54,608 --> 01:12:57,342
before you start calling methods on yourself or
你才能开始调用自身的方法

1365
01:12:57,410 --> 01:12:58,309
accessing properties.
或者访问自身的属性

1366
01:12:58,378 --> 01:12:59,844
Not setting the properties, but accessing them.
不是设置属性的初始值，而是访问它们

1367
01:12:59,913 --> 01:13:02,580
In other words, you have to be fully initialized before your
换句话说就是，在你的便利构造器开始使用这个类之前

1368
01:13:02,649 --> 01:13:07,318
init can start using your class. All right,
你必须先完全构造自身

1369
01:13:07,387 --> 01:13:11,523
whew is right: a lot of rules there, and a lot of them
呼，终于讲完了这一大堆规则

1370
01:13:11,592 --> 01:13:15,260
are conflicting and all that stuff. Let's make it even more
而且其中一部分还相互冲突，纠缠不清

1371
01:13:15,329 --> 01:13:18,296
complicated when we talk about inheriting inits. So,
接下来讲继承构造器，事情会变得更复杂

1372
01:13:18,365 --> 01:13:20,832
you wanna get some inits from your super class,
你可能希望从父类继承一些构造器

1373
01:13:20,901 --> 01:13:24,402
whoa, not so fast. If you don't implement
不过先别急。如果你没有实现任何一个指定构造器

1374
01:13:24,471 --> 01:13:27,439
any designated inits, you only implement convenience inits,
你只实现了一些便利构造器

1375
01:13:27,507 --> 01:13:30,943
then you'll inherit all of your super classes designated,
这样的话你就能继承所有父类的指定构造器

1376
01:13:31,011 --> 01:13:32,744
but only if you don't implement any of them.
但是前提是你没有实现任何一个指定构造器

1377
01:13:32,813 --> 01:13:35,146
And if you implement even one designated init,
哪怕你只实现了一个指定构造器

1378
01:13:35,215 --> 01:13:38,984
now you're not gonna inherit all your super classes. If you
你就没法继承父类的任何指定构造器

1379
01:13:39,053 --> 01:13:43,154
override all of your super classes designated inits,
如果你重写了父类所有的指定构造器

1380
01:13:43,223 --> 01:13:47,926
then you'll inherit all of its con, convenience inits.
你就能继承父类所有的便利构造器

1381
01:13:47,995 --> 01:13:49,861
Now why is that? That's because your superclass,
为什么会这样呢？因为你的父类

1382
01:13:49,930 --> 01:13:52,297
when it implements these convenience inits,
实现它的便利构造器

1383
01:13:52,366 --> 01:13:55,534
it depends on the designated inits being implemented,
要建立在指定构造器已经实现的基础上

1384
01:13:55,602 --> 01:13:57,469
so you have to implement them all.
所以你要实现父类全部的指定构造器

1385
01:13:57,538 --> 01:13:59,337
Of course, you could inherit them all by implementing
当然，如果你没有实现任何一个指定构造器

1386
01:13:59,406 --> 01:14:04,008
none of them as well. So, any init that you inherit by these
也一样能继承父类全部的便利构造器

1387
01:14:04,077 --> 01:14:06,611
rules can be used to satisfy any of these other,
你通过这些规则继承来的构造器也一样满足

1388
01:14:06,680 --> 01:14:09,982
other requirements that we're talking about on the previous
我们上一页讲到的“必须做的事情”

1389
01:14:10,050 --> 01:14:13,151
stage. You can make an init required. You just say
你可以通过 required init 把一个构造器变为必要构造器

1390
01:14:13,220 --> 01:14:16,187
required init. Required is a key word, and that will
required 是一个关键词

1391
01:14:16,256 --> 01:14:19,424
make it so the subclass has to implement that init, okay,
它要求所有子类必须实现这个构造器

1392
01:14:19,492 --> 01:14:23,628
it's required. Failable inits, we talked about these with
因为它是“必要的”。可失败构造器，我们以 Double 为例

1393
01:14:23,697 --> 01:14:26,664
double. If you put a question mark after your init,
如果你在 init 后面加一个问号

1394
01:14:26,733 --> 01:14:29,534
init question mark, that means that this init can fail.
init? 代表它是可失败的

1395
01:14:29,603 --> 01:14:32,871
And that means that this init, or when you create this thing,
意味着这个构造器，或者说当你创建这个实例的时候

1396
01:14:32,940 --> 01:14:35,740
will return optional version of this class. So
返回的是这个类型的可选类型

1397
01:14:35,809 --> 01:14:37,108
we thought it was double.
我们想一下 Double

1398
01:14:37,177 --> 01:14:39,878
If we said double parentheses string, it would return
如果我们通过传入一个字符串构造 Double

1399
01:14:39,947 --> 01:14:42,214
an optional double. It was a failable init, and
会返回一个 Double? 这就是一个可失败构造器

1400
01:14:42,282 --> 01:14:44,316
that's because you could have said double of hello, and
因为你有可能这样写：Double("hello")

1401
01:14:44,384 --> 01:14:46,451
you would be like " I can't turn it into double: fail".
你会得到这样的回答“我没法把它转化为 Double，失败了”

1402
01:14:46,519 --> 01:14:49,421
And the way you fail out of a failable init is you just
这种失败具体表现就是你得到的返回值是 nil

1403
01:14:49,489 --> 01:14:51,255
return nil. Otherwise,
另外

1404
01:14:51,324 --> 01:14:53,758
you don't return anything out of init, it just initializes,
通常你不用在构造器里写 return，因为它本身就是构造器

1405
01:14:53,827 --> 01:14:55,827
but the one time you return anything is out
但是仅有一种情况你要写 return

1406
01:14:55,896 --> 01:14:58,730
a failed init, you can return nil. So, an example here is
那就是可失败构造器失败的时候，你要 return nil

1407
01:14:58,799 --> 01:15:02,968
UIImage. UIImaged named looks up that image in
拿 UIImage 举例，UIImage(named:) 会在

1408
01:15:03,036 --> 01:15:05,904
the xcassets. Remember that xcassets thing that I moved
xcassets 文件中寻找指定的图片。还记得 xcassets 文件吗？

1409
01:15:05,973 --> 01:15:08,806
off to supporting files at the beginning of the first demo?
就是第一个 demo 中我移动到 Supporting Files 文件夹的那个

1410
01:15:08,875 --> 01:15:12,044
This looks it up in there, of course, it might not find it.
这个方法就是在那里寻找图片，当然有可能找不到

1411
01:15:12,113 --> 01:15:15,614
So we do if let image = UIImage(named: "foo"),
所以我们要这样写 if let image = UIImage(named: "foo")

1412
01:15:15,683 --> 01:15:17,516
then we do something, otherwise we fail,
如果找到了我们会做某些操作

1413
01:15:17,584 --> 01:15:22,754
that UIImage initializer failed. Alright, Any and
如果 UIImage 构造失败我们就什么都不做

1414
01:15:22,822 --> 01:15:27,259
AnyObject. There is no more init, we're done with init.
下面是 Any 和 AnyObject，不讲构造器了

1415
01:15:27,327 --> 01:15:31,262
Any and AnyObject: these are types, special types.
Any 和 AnyObject 都是类型，特殊的类型

1416
01:15:31,331 --> 01:15:35,133
These types really are almost exclusively used for backwards
几乎可以这样理解，这些类型的存在仅仅是为了

1417
01:15:35,202 --> 01:15:39,004
compatibility with Objective C because Objective C had a type
向下兼容 Objective-C 中叫做 id 的一个类型

1418
01:15:39,072 --> 01:15:41,740
in it called id, which was kind of like Any,
它和 Any 类似

1419
01:15:41,809 --> 01:15:46,444
AnyObject actually. So Swift needed some compatibility, but
确切地说它更像 AnyObject。Swift 需要兼容这些

1420
01:15:46,513 --> 01:15:48,980
Swift doesn't really use Any very much, so
Swift 中用到 Any 的情况并不多

1421
01:15:49,049 --> 01:15:52,884
we wouldn't, Swift is strongly typed. So you wouldn't wanna
Swift 是一个强类型语言

1422
01:15:52,953 --> 01:15:55,553
have a type which is like, it can be anything. Okay, because
一个能代表任意类型的类型，没有存在的必要

1423
01:15:55,622 --> 01:15:58,022
that's what Any and AnyObject are, it's like anything,
Any 和 AnyObject 能代表任何类型

1424
01:15:58,091 --> 01:16:02,928
any type. It's this weird kind of typeless type kinda thing.
它们指代的是类型不明的东西

1425
01:16:02,997 --> 01:16:04,062
The only difference between Any and
Any 与 AnyObject 唯一的区别是

1426
01:16:04,131 --> 01:16:06,197
AnyObject is AnyObject can only be a class,
AnyObject 只能指代某个类

1427
01:16:06,266 --> 01:16:08,900
it has be a reference type. Any can be anything,
必须是引用类型，Any 没有这个限制

1428
01:16:08,969 --> 01:16:12,070
reference or a value type, that's the only difference.
引用类型或值类型都可以，这是它们之间唯一的区别

1429
01:16:12,139 --> 01:16:14,406
So why do we have these AnyObject things?
为什么要有 AnyObject 和 Any？

1430
01:16:14,475 --> 01:16:15,841
Where are they gonna show up? Well,
它们要用在哪里？

1431
01:16:15,909 --> 01:16:18,710
there are some methods in iOS where one of the arguments
iOS 中有一些方法确实能接受任何类型的参数

1432
01:16:18,779 --> 01:16:22,847
truly could be anything. One example here is when you have
比如：当你有很多 MVC 时

1433
01:16:22,916 --> 01:16:25,316
multiple MVCs, which we're gonna learn about next week.
这个我们下周会详细学

1434
01:16:25,385 --> 01:16:28,687
The way you go from one to the next, next is called segueing,
从一个跳转到另一个的方式叫做 Segue

1435
01:16:28,755 --> 01:16:30,622
you segue from one MVC to the next.
你能从一个 MVC Segue 到下一个

1436
01:16:30,690 --> 01:16:33,926
And the thing that causes a segue to happen, okay,
Segue 的发起者

1437
01:16:33,994 --> 01:16:37,095
is the argument in this method called prepare for
就是方法 prepare(for:sender:) 中

1438
01:16:37,164 --> 01:16:39,031
segue called sender, okay,
叫做 sender 的参数

1439
01:16:39,099 --> 01:16:42,067
just like we had sender in the IB action. So
和我们之前用到的 IBAction 中的 sender 是相似的

1440
01:16:42,136 --> 01:16:44,636
the sender is the one who's causing this segue to happen,
这个 sender 就是 Segue 的发起者

1441
01:16:44,704 --> 01:16:46,871
well, a button could be causing a segue to happen,
一个按钮可以发起 Segue

1442
01:16:46,940 --> 01:16:49,507
a line in a table view could be causing it. Some custom
TableView 中的一行也可以

1443
01:16:49,576 --> 01:16:53,211
piece of code of yours could be causing this MVC to segue.
一小段自定义的代码也可以

1444
01:16:53,280 --> 01:16:55,914
So when you're preparing for it, you've gotta be
所以当你准备 Segue 的时候

1445
01:16:55,983 --> 01:16:59,918
able to say which one it was, and that's just Any. So
你要能接受任何类型的 sender，所以这里用 Any

1446
01:16:59,987 --> 01:17:02,621
if this were a Swift API, they wouldn't have done Any.
不过如果是一个纯 Swift API，通常不会用 Any

1447
01:17:02,690 --> 01:17:05,958
They'd have had a protocol where you could be a segue
应该有一个协议类型代表那些能当做 Segue 发起者的东西

1448
01:17:06,026 --> 01:17:09,260
sender. And you'd have to implement probably some
而且你还要为这个协议实现一些合适的功能

1449
01:17:09,329 --> 01:17:14,099
functionality that would make sense here. But in this case,
使它可以在这里发挥作用。但是现在这里用的是 Any

1450
01:17:14,167 --> 01:17:17,302
it's Any. It knows optional Any too because you can have
而且是 Any?，因为这里它可以是 nil

1451
01:17:17,371 --> 01:17:20,339
nil, the sender could be nil. Where else will you see it?
sender 可以是 nil。还有哪里能遇到这种用法？

1452
01:17:20,407 --> 01:17:25,110
You could have an array of AnyObject or an array of Any.
你可以有一个以 AnyObject 或 Any 为元素的数组

1453
01:17:25,178 --> 01:17:28,113
That could be an array that has doubles and strings and
这样的数组能够同时包含 Double 和 String

1454
01:17:28,182 --> 01:17:31,283
things mixed in there. Now you might be tempted to use this
当你看到作业二的内容之后

1455
01:17:31,352 --> 01:17:34,786
in your assignment number two when you see the assignment.
你可能对这种用法跃跃欲试

1456
01:17:34,855 --> 01:17:35,721
But you're not allowed to
但是我不允许你们用

1457
01:17:35,789 --> 01:17:37,789
because one of the required tasks says you can't use Any
作业的要求中有一条写明了

1458
01:17:37,858 --> 01:17:41,493
or AnyObject. Also you wouldn't be very Swifty.
你不能用 Any 或 AnyObject。这种用法很不 Swifty

1459
01:17:41,562 --> 01:17:43,461
In Swift, if we wanted to put doubles and
Swift 中，如果我们要把 Double 和 String

1460
01:17:43,530 --> 01:17:46,265
strings in the same array, we use an enum.
放入同一个数组，应该使用 enum（枚举）

1461
01:17:46,333 --> 01:17:48,200
That's what we did with our operations array, and that's
就像之前 CalculatorBrain 中存放操作符的数组

1462
01:17:48,268 --> 01:17:51,236
what we would do in Swift, so we wouldn't use AnyObject.
这才是我们在 Swift 中实现的方式，不要用 AnyObject

1463
01:17:51,305 --> 01:17:53,171
Another thing you could possibly use Any for is for
另外，可能用到 Any 的一种情况是

1464
01:17:53,240 --> 01:17:55,374
a cookie, right, some piece of data that you're giving
cookie，指的是：你要发送出去的一串数据

1465
01:17:55,442 --> 01:17:57,576
out that you don't want people to know what class it is.
你不希望别人知道它是什么类型

1466
01:17:57,645 --> 01:17:59,411
And they're just gonna give it back to you at some point,
他们只需要在某个时候原封不动的返回给你

1467
01:17:59,480 --> 01:18:00,578
and you'll do something with it and
然后你会对它做一些操作

1468
01:18:00,647 --> 01:18:01,379
only you know what it is.
只有你知道它是什么

1469
01:18:01,448 --> 01:18:03,514
So you know, an opaque type, you could use it for
只有你知道它的隐藏类型，只有你能用它

1470
01:18:03,583 --> 01:18:07,986
that. How do we use something of type Any, because we can't
我们要怎么使用 Any 类型的变量呢？

1471
01:18:08,055 --> 01:18:10,822
send any messages to it cuz it's not of any type, so
我们没法给 Any 类型的变量发送消息。它不是任何类型

1472
01:18:10,891 --> 01:18:14,426
we don't know any methods that it does or whatever. Instead,
我们不知道它有哪些方法，我们对它一无所知

1473
01:18:14,494 --> 01:18:18,062
we have convert it, and we convert type Any or, or
所以我们必须对它进行转换，我们要把 Any 或 AnyObject

1474
01:18:18,131 --> 01:18:23,001
AnyObject into some class that we know about using as.
用 as 转换为我们已知的类型

1475
01:18:23,070 --> 01:18:26,205
As is a key word, and we do as question mark because we don't
as 是一个关键词，我们用 as? 是因为

1476
01:18:26,273 --> 01:18:28,073
know for sure that we can convert something,
我们也不确定它是不是能被转换成功

1477
01:18:28,142 --> 01:18:31,844
so it's an optional. And we use it with if let.
所以它是可选类型，我们通常和 if let 一起使用

1478
01:18:31,912 --> 01:18:33,412
So if I had some variable unknown,
如果我有一个未知类型的变量

1479
01:18:33,480 --> 01:18:36,214
which is of type Any, so I don't really know what it is.
它是 Any 类型，我不知道它的真实类型

1480
01:18:36,283 --> 01:18:39,284
But I think it might be MyType, I'm not sure.
但是我认为它可能 MyType 类型的，我也不太确定

1481
01:18:39,353 --> 01:18:42,487
But I think that might be MyType in there. So I say,
我认为它是 MyType，所以我可以写

1482
01:18:42,556 --> 01:18:46,825
if let foo = unknown as? MyType,
if let foo = unknown as? MyType

1483
01:18:46,894 --> 01:18:52,197
if let. Then inside there, foo is now going to be unknown,
if let，然后 foo 就是那个未知的东西转换为 MyType 后的结果

1484
01:18:52,265 --> 01:18:56,668
but as MyType. So I will be able to
所以我能给 foo 发消息

1485
01:18:56,737 --> 01:18:59,738
send foo message whatever MyType, I'll be able to send foo
发送任何 MyType 可以接受的消息

1486
01:18:59,807 --> 01:19:02,341
whatever MyType understands, methods and vars.
任何它的方法或变量

1487
01:19:04,311 --> 01:19:06,478
So that's how we use it. We use this "as?", it's called
通过用 as? 这种方法，我们得以使用 Any 类型的变量

1488
01:19:06,547 --> 01:19:09,614
casting. This casting, by the way, not just for AnyObject,
这种操作叫 Casting（类型检查）。不仅是 AnyObject 和 Any

1489
01:19:09,683 --> 01:19:12,951
we can cast other things. For example, if I had a variable
其他类型我们也可以检查。比如有一个变量 vc

1490
01:19:13,020 --> 01:19:15,987
which is, vc which is a type UIViewController,
它的类型是 UIViewController

1491
01:19:16,056 --> 01:19:19,324
I could assign it to UI, to CalculatorViewController.
我可以让它指向一个 CalculatorViewController

1492
01:19:19,393 --> 01:19:20,325
Because CalculatorViewController is
因为 CalculatorViewController 是

1493
01:19:20,393 --> 01:19:21,927
a subclass of UIViewController. So
UIViewController 的子类

1494
01:19:21,995 --> 01:19:26,031
it is a UIViewController, so I could assign it to vc. But
所以它也是一个 UIViewController，我可以用 vc 指向它

1495
01:19:26,099 --> 01:19:28,933
if I assign it like this, with this typing,
但是这样操作之后

1496
01:19:29,002 --> 01:19:32,604
I cannot say vc.displayValue cuz vc.displayValue,
我就没法访问 vc.displayValue 了

1497
01:19:32,672 --> 01:19:36,208
displayValue is a var in CalculatorViewController,
因为 displayValue 是 CalculatorViewController 的变量

1498
01:19:36,277 --> 01:19:38,643
and vc is of type UIViewController.
但是 vc 是 UIViewController 类型的

1499
01:19:38,712 --> 01:19:41,246
Even though it points to a CalculatorViewController,
尽管它实际指向的是 CalculatorViewController

1500
01:19:41,315 --> 01:19:43,681
from Swift's perspective, it's typed as vc, and
但是 Swift 现在把他视为 vc 的类型

1501
01:19:43,750 --> 01:19:47,753
Swift is strongly typed. So if I wanted to send displayValue,
因为 Swift 是强类型语言，如果我要访问 displayValue

1502
01:19:47,821 --> 01:19:50,655
I would have to say, if I can let calcVC = vc
我只能这样写 if let calcVC = vc as? CalculatorViewController

1503
01:19:50,724 --> 01:19:55,127
as a CalculatorViewController Now I can send displayValue to
之后我才能访问 calcVC 的 displayValue 属性

1504
01:19:55,195 --> 01:19:59,598
calcVC. Cuz it's the type that you actually
因为 vc 明确声明了类型

1505
01:19:59,667 --> 01:20:02,234
type it as that matters, not what it's pointing to. So you
所以 Swift 不考虑实际指向的类型

1506
01:20:02,302 --> 01:20:04,870
have to use as to get it to be something that you really
因此使用前必须先转换为你想要的那个类型

1507
01:20:04,939 --> 01:20:08,606
wanna use. Okay, I'm gonna go a little bit over here.
我会稍微拖点堂

1508
01:20:08,675 --> 01:20:11,376
If you have to go, it's, it's fine, just keep it quiet.
如果有人要走，可以先走，保持安静

1509
01:20:11,445 --> 01:20:13,778
The last thing I'm gonna talk about is user defaults.
最后一个知识点是 UserDefaults

1510
01:20:13,847 --> 01:20:15,647
User defaults is a very lightweight,
它是一个轻量级的、受限制的数据库

1511
01:20:15,716 --> 01:20:19,618
limited database. It's a tiny little database that persists
它是一个可以在应用多次启动之间

1512
01:20:19,687 --> 01:20:21,687
between launchings of your app. It's great for
保存持久化数据的微型数据库，非常适合用来

1513
01:20:21,756 --> 01:20:23,255
things like settings and stuff like that.
保存设置信息，或者类似的东西

1514
01:20:23,323 --> 01:20:26,424
Don't put anything big in there. The only thing you can
不要保存太大的数据

1515
01:20:26,493 --> 01:20:29,227
put in this database is what's called a property list.
你只能保存 Property List（属性列表）形式的数据

1516
01:20:29,296 --> 01:20:32,331
A property list just means any combination of array,
属性列表是以下这些类型的混合体：Array

1517
01:20:32,399 --> 01:20:34,133
dictionary, string, date, data, or
Dictionary、String、Date、Data

1518
01:20:34,201 --> 01:20:37,702
a number, like int, float, double, whatever.
或者 Int，Float，Double 等任意类型的数字

1519
01:20:37,771 --> 01:20:40,038
That's what a property list is. It's just conceptual.
这就是属性列表的概念

1520
01:20:40,107 --> 01:20:42,707
There's no actual type property list, unfortunately.
并没有一个与之对应的真实类型

1521
01:20:42,776 --> 01:20:45,910
If this were a Swift API, it probably would be such a type.
如果这是个 Swift 的 API，它可能是一个确切类型

1522
01:20:45,979 --> 01:20:48,180
It could be a protocol. But anyway, there's not.
可能是个协议类型，可惜并不是

1523
01:20:48,248 --> 01:20:51,883
This is from Objective-C. So since there's no type
这是一个来自 Objective-C 的东西

1524
01:20:51,952 --> 01:20:55,287
that represents that hodgepodge of classes,
所以没有一个类型能代表这个大杂烩

1525
01:20:55,355 --> 01:20:58,823
this API that I'm gonna show user defaults uses Any. And
下面我要向你们介绍的 UserDefaults API 中使用了 Any

1526
01:20:58,892 --> 01:21:01,593
this is what it looks like. It has this core, set, and
它们看上去是这样的，它的核心方法 set 和 get

1527
01:21:01,662 --> 01:21:05,931
get. Set Any? Now that Any can't really be Any,
set 接受 Any? 类型。注意这里 Any 并不是任何类型都可以

1528
01:21:06,000 --> 01:21:07,933
it has to be one of those types, string, dictionary,
它必须是这几种确切类型之一：String、Dictionary、Array 等

1529
01:21:08,001 --> 01:21:09,601
array, whatever, it has to be be a Property List,
总之它必须是一个属性列表

1530
01:21:09,670 --> 01:21:13,004
forKey string. So you just put it, anything you want
forKey: String 意味着你要设置一个关键字

1531
01:21:13,073 --> 01:21:14,506
in this database under a certain key.
什么都可以，数据将会被存储在这个关键字下

1532
01:21:14,575 --> 01:21:16,641
And then you get it back out by saying, object for key, and
然后你也可以获取里面的内容，通过 object(forKey:) 方法

1533
01:21:16,710 --> 01:21:19,210
it returns you an Any. And it's an optional Any because
它会返回给你一个 Any?，一个可选类型的 Any

1534
01:21:19,279 --> 01:21:20,445
it might not be in the database,
因为数据库里可能没有指定关键字的数据

1535
01:21:20,514 --> 01:21:23,247
in which it is returned nil. So it says any but
这时就会返回 nil。虽然它返回 Any

1536
01:21:23,316 --> 01:21:27,286
it's not really Any, it's Any as long as the property lists,
但是这个 Any 并不是什么都可以，它依然还是个属性列表

1537
01:21:27,354 --> 01:21:29,521
which means it's one of these ten classes or
意味着它只能是那十种类型之一

1538
01:21:29,590 --> 01:21:32,123
whatever. The way you read and
这就是读取和写入它的方法

1539
01:21:32,192 --> 01:21:35,427
write it, you don't create a user default by saying let
你不需要通过 let x = UserDefaults()

1540
01:21:35,496 --> 01:21:37,595
x equal user defaults with parentheses.
创建一个 UserDefaults

1541
01:21:37,664 --> 01:21:41,533
You say let defaults = UserDefaults.standard, so
你应该通过 let defaults = UserDefaults.standard

1542
01:21:41,601 --> 01:21:45,270
that's a type var on the user default struct.
这是一个 UserDefaults 的类型变量

1543
01:21:45,339 --> 01:21:47,572
And you get this standard UserDefaults and
你可以取得这个叫做 standard 的 UserDefaults

1544
01:21:47,641 --> 01:21:49,541
then you can send it things like set,
然后你可以调用它的 set 方法

1545
01:21:49,610 --> 01:21:52,410
that thing I was telling you, set Any. And here,
像刚刚讲过的那样 set 任何属于属性列表的类型

1546
01:21:52,479 --> 01:21:55,446
I've got three different sets, one of them setting of double,
这里我展示了三种不同的 set，其一设置了 Double

1547
01:21:55,515 --> 01:21:58,016
one setting an array of ints. An array of ints is okay
另一个设置了一个 Int 类型的数组，这是允许的

1548
01:21:58,085 --> 01:22:01,086
because array is part of property list. And so is int,
因为数组可以是属性列表的一部分，Int 也行

1549
01:22:01,155 --> 01:22:04,355
so that's okay. That's a property list. An array
所以 Int 类型的数组是完全可以的，它是一个属性列表

1550
01:22:04,424 --> 01:22:06,424
of ints is a property list, a property list. So is a double,
Int 类型的数组是属性列表，一个单独的 Double 也是

1551
01:22:06,493 --> 01:22:09,061
cuz it's one of those types. And I just set them in there.
因为它也是属性列表包含的类型之一。这里我 set 过了

1552
01:22:09,129 --> 01:22:12,497
And then when I get them out, I use that object for key.
当我要 get 的时候，我要用 object(forKey:) 方法

1553
01:22:12,565 --> 01:22:14,432
And actually for some common types,
我要获取的是常见的类型

1554
01:22:14,501 --> 01:22:17,202
like doubles, arrays and dictionaries, there's actually
比如 Double，Array 或者 Dictionary

1555
01:22:17,271 --> 01:22:19,905
a nice little method in there to give you that type back.
有一些很便利的方法可以帮你直接取回指定的类型

1556
01:22:19,973 --> 01:22:23,441
That's so you that don't get an Any back and
这样你就不用先拿到一个 Any，然后在对它进行 as 操作了

1557
01:22:23,510 --> 01:22:26,778
then have to do as. Because you know that objects for
因为通过 object(forKey:) 拿到的是 Any

1558
01:22:26,847 --> 01:22:29,547
key returns an Any until you get this Any and
你拿到它之后

1559
01:22:29,616 --> 01:22:32,217
you have to go if this thing as a double,
还要去判断它能不能 as 成 Double

1560
01:22:32,286 --> 01:22:34,286
then I've got it. That would be annoying. So instead,
然后才算真正拿到了它，这种做法太麻烦

1561
01:22:34,354 --> 01:22:36,789
it just has a method called double that does that as for
作为替代，叫做 double(forKey:) 的方法帮你做了 as 的工作

1562
01:22:36,857 --> 01:22:40,825
you. And if the as fails then you, I think either,
而且如果获取失败了，我想想

1563
01:22:40,894 --> 01:22:43,094
I don't know if it returns a double or an optional double,
我也忘了它会返回 Double 还是 Double?

1564
01:22:43,163 --> 01:22:45,930
but you might get zero back, you might get a nil.
你可能得到 0，也可能是 nil

1565
01:22:45,999 --> 01:22:49,201
I don't remember exactly. But for array and dictionary,
我也记不清了。对于字典或数组

1566
01:22:49,269 --> 01:22:52,804
a couple of interesting things to note. Obviously,
它们有些有趣的特点，要特别注意

1567
01:22:52,873 --> 01:22:56,074
the Anys that are inside the array and dictionary,
它们作为返回值时，其中包含的元素 Any

1568
01:22:56,143 --> 01:22:59,077
those will have to be property lists as well, the things that
一样必须是属性列表

1569
01:22:59,145 --> 01:23:01,446
are returned to you. And also know that dictionary,
对于字典

1570
01:23:01,514 --> 01:23:03,915
this convenience method dictionary,
有一个方法是 dictionary(forKey:)

1571
01:23:03,984 --> 01:23:07,552
it's the string is always the key in the dictionary.
它的键必须是 String 类型的

1572
01:23:07,621 --> 01:23:12,157
If you had a dictionary where the keys were say, ints.
如果你有一个字典，键类型是 Int

1573
01:23:12,226 --> 01:23:14,926
I think that's a valid key, yeah, in the dictionary, yeah,
我记得 Int 是一个可以作为键的类型，没错，确实是

1574
01:23:14,995 --> 01:23:18,029
it is. Then you would not use this convenience method.
那你就不能用这个方法了

1575
01:23:18,098 --> 01:23:21,867
You'd have to use object for key and then use as to turn it
你必须用 object(forKey:) 然后再用 as 把它转换为

1576
01:23:21,936 --> 01:23:26,971
back into a dictionary with int keys.
以 Int 为键类型的字典

1577
01:23:27,040 --> 01:23:29,307
Saving the database is autosave, so you actually
这个数据库的保存是自动的

1578
01:23:29,376 --> 01:23:31,276
don't have to save it. If you wanna force it to save because
你没必要手工去保存它。如果你害怕自动保存会失效

1579
01:23:31,344 --> 01:23:33,144
you're worried that the autosave might not happen.
你希望强制保存它

1580
01:23:33,213 --> 01:23:35,413
You're gonna exit your program or something, you can use this
比如你可能强退了程序

1581
01:23:35,482 --> 01:23:37,382
method synchronize. It's called synchronize defaults.
你可以用这个方法手动同步：defaults.synchronize()

1582
01:23:37,451 --> 01:23:40,586
It will synchronize it. That's almost it, assertions.
它会同步数据库。最后是 Assertions（断言）

1583
01:23:40,654 --> 01:23:44,222
Sorry, one last quick thing. Assertions are just a little
抱歉，只剩最后一个小知识点了

1584
01:23:44,291 --> 01:23:48,360
Swift function that takes a closure as the first argument
断言只是 Swift 中的一个小函数，第一个参数是个闭包

1585
01:23:48,429 --> 01:23:51,596
and a message as the second argument.
第二个参数是一个消息字符串

1586
01:23:51,665 --> 01:23:55,400
All it does is it executes the closure. If that returns true,
它做的仅仅是执行这个闭包，如果返回为 true

1587
01:23:55,469 --> 01:23:58,437
it does not crash your program. If it returns false,
就什么都不做。如果返回为 false

1588
01:23:58,505 --> 01:24:02,006
it crashes your program and prints that message out. So
就会导致你的程序崩溃掉，并且输出这段消息

1589
01:24:02,075 --> 01:24:06,778
you could put, you know, some validation call. This line of
所以你可以把它用于验证合法性

1590
01:24:06,847 --> 01:24:10,215
code will not even execute in the version of your app that
在你发布到 App Store 的版本中，这行代码不会执行

1591
01:24:10,284 --> 01:24:12,618
you ship on the app store. When you build the app for
当你用 Release 模式生成程序的时候

1592
01:24:12,686 --> 01:24:15,086
release, the asserts are completely ignored.
断言会被完全忽略掉

1593
01:24:15,155 --> 01:24:17,890
It doesn't even actually give the closure, let alone crash.
不会执行这段闭包，更不会崩溃

1594
01:24:17,958 --> 01:24:20,592
It just ignores them, so this is a debugging thing only,
仅仅是忽略掉它们。这只是个调试用的东西

1595
01:24:20,661 --> 01:24:24,863
okay? That's it! For Friday,
好了，讲完了

1596
01:24:24,932 --> 01:24:27,899
we do have Friday session, it's at the normal time. And
这周五我们会上课，老时间

1597
01:24:27,968 --> 01:24:29,568
it's gonna be on source code management.
会讲一些源码管理的知识

1598
01:24:29,637 --> 01:24:33,471
A really cool way to manage your code even if you're just
一种非常酷的管理源码的方法

1599
01:24:33,540 --> 01:24:36,074
one programmer working on a project by yourself. And then
即使你独自做项目，也有必要学习

1600
01:24:36,143 --> 01:24:39,010
next week I'm going to talk about doing custom drawing
下周我会讲自定义视图中的绘制

1601
01:24:39,079 --> 01:24:42,447
in your own view. Multi-touch, like pinches and swipes, and
还有各种手势，比如 Pinch（捏合）和 Swipe（轻扫）等

1602
01:24:42,516 --> 01:24:45,450
things like that. And finally, multiple MVCs so
最后是有关多个 MVC 的知识

1603
01:24:45,519 --> 01:24:48,119
we can build a more powerful calculator.
我们可以构建一个更强大的计算器

1604
01:24:48,188 --> 01:24:51,123
Your assignment two has gone out. It's already posted.
作业二已经布置完毕，发布出来了

1605
01:24:51,191 --> 01:24:54,259
It's essentially enhancing your calculator with a lot of
主要内容是加强你的计算器

1606
01:24:54,328 --> 01:24:57,129
the things that I talked about today like tuples and
运用我们今天讲的很多知识

1607
01:24:57,198 --> 01:24:59,831
defaulting values and even value types.
比如元组和默认值，还有值类型

1608
01:24:59,899 --> 01:25:01,934
All kinds of stuff. So we'll have a lot of fun with that.
运用各种知识去完成它，享受这个有趣的过程吧

1609
01:25:03,237 --> 01:25:03,935
>> For more,
>> 更多课程

1610
01:25:04,004 --> 01:25:12,510
please visit us at stanford.edu
详见 stanford.edu
